// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package oasis

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = abi.U256
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// OasisABI is the input ABI used to generate the binding from.
const OasisABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"matchingEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sell_gem\",\"type\":\"address\"},{\"name\":\"buy_gem\",\"type\":\"address\"}],\"name\":\"getBestOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"name\":\"buy_gem\",\"type\":\"address\"},{\"name\":\"min_fill_amount\",\"type\":\"uint256\"}],\"name\":\"sellAllAmount\",\"outputs\":[{\"name\":\"fill_amt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"buy_gem\",\"type\":\"address\"},{\"name\":\"pay_amt\",\"type\":\"uint128\"},{\"name\":\"buy_amt\",\"type\":\"uint128\"}],\"name\":\"make\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"buy_gem\",\"type\":\"address\"},{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"pay_amt\",\"type\":\"uint256\"}],\"name\":\"getBuyAmount\",\"outputs\":[{\"name\":\"fill_amt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"name\":\"buy_gem\",\"type\":\"address\"},{\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"offer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"insert\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_offer_id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchingEnabled_\",\"type\":\"bool\"}],\"name\":\"setMatchingEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"del_rank\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"maxTakeAmount\",\"type\":\"uint128\"}],\"name\":\"take\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pay_gem\",\"type\":\"address\"}],\"name\":\"getMinSell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dustId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getNextUnsortedOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"close_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_span\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_best\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id_\",\"type\":\"bytes32\"}],\"name\":\"bump\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sell_gem\",\"type\":\"address\"},{\"name\":\"buy_gem\",\"type\":\"address\"}],\"name\":\"getOfferCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buy_gem\",\"type\":\"address\"},{\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"max_fill_amount\",\"type\":\"uint256\"}],\"name\":\"buyAllAmount\",\"outputs\":[{\"name\":\"fill_amt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offers\",\"outputs\":[{\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"name\":\"buy_gem\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstUnsortedOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetterOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_dust\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getWorseOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_near\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"dust\",\"type\":\"uint256\"}],\"name\":\"setMinSell\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isClosed\",\"outputs\":[{\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_rank\",\"outputs\":[{\"name\":\"next\",\"type\":\"uint256\"},{\"name\":\"prev\",\"type\":\"uint256\"},{\"name\":\"delb\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isOfferSorted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyEnabled_\",\"type\":\"bool\"}],\"name\":\"setBuyEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"name\":\"buy_gem\",\"type\":\"address\"},{\"name\":\"pos\",\"type\":\"uint256\"},{\"name\":\"rounding\",\"type\":\"bool\"}],\"name\":\"offer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"name\":\"buy_gem\",\"type\":\"address\"}],\"name\":\"offer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pay_gem\",\"type\":\"address\"},{\"name\":\"buy_gem\",\"type\":\"address\"},{\"name\":\"buy_amt\",\"type\":\"uint256\"}],\"name\":\"getPayAmount\",\"outputs\":[{\"name\":\"fill_amt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"close_time\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogItemUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pay_amt\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buy_amt\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buy_gem\",\"type\":\"address\"}],\"name\":\"LogTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buy_gem\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pay_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"buy_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogMake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buy_gem\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pay_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"buy_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogBump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buy_gem\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"take_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"give_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogTake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"pair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buy_gem\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pay_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"buy_amt\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"LogKill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"LogBuyEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pay_gem\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"min_amount\",\"type\":\"uint256\"}],\"name\":\"LogMinSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"LogMatchingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogUnsortedOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogSortedOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogInsert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogDelete\",\"type\":\"event\"}]"

const HexAddr = "0x39755357759cE0d7f32dC8dC45414CCa409AE24e"

// OasisBin is the compiled bytecode used for deploying new contracts.
const OasisBin = `608060405260048054605860020a60ff0219605060020a60ff02199091166a010000000000000000000017166b01000000000000000000000017905534801561004757600080fd5b50604051602080613420833981016040819052905160018054600160a060020a0319163390811790915590918291907fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9490600090a26004805467ffffffffffffffff9092166101000268ffffffffffffffff00199092169190911790555061334c806100d46000396000f3006080604052600436106102455763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166301492a0b811461024a5780630374fc6f146102735780630621b4f6146102ac57806307da68f5146102da578063093f5198146102f157806313af40351461032a578063144a27521461034b5780631b33d412146103755780631d834a1b146103a6578063232cae0b146103c15780632aed1905146103d657806340e58ee5146103f05780634579268a14610408578063467f0b7b146104515780634960645514610469578063511fa4871461048d578063557ed1ba146104ae57806356ad8764146104e057806361f54a79146104f55780636377ebca1461050d578063677170e11461052257806374c1d7d31461054957806375f12b2114610570578063779997c3146105855780637a9e5e4b1461059d5780637ca9429a146105be5780638185402b146105e557806382afd23b146106135780638a72ea6a1461062b5780638af82a2e1461068d5780638da5cb5b146106a2578063911550f4146106d357806391be90c8146106eb578063943911bc1461070c578063a78d431614610724578063b4f9b6c81461073c578063bf7c734e14610754578063bf7e214f14610778578063c2b6b58c1461078d578063c2d526aa146107a2578063c41a360a146107d8578063d2b420ce146107f0578063d6f1546914610808578063d6febde814610822578063e1a6f0141461083d578063f09ea2a614610873578063f582d293146108a1578063ff1fd974146108b6575b600080fd5b34801561025657600080fd5b5061025f6108e0565b604080519115158252519081900360200190f35b34801561027f57600080fd5b5061029a600160a060020a03600435811690602435166108f8565b60408051918252519081900360200190f35b3480156102b857600080fd5b5061029a600160a060020a036004358116906024359060443516606435610925565b3480156102e657600080fd5b506102ef610ab4565b005b3480156102fd57600080fd5b5061029a600160a060020a03600435811690602435166001608060020a0360443581169060643516610af6565b34801561033657600080fd5b506102ef600160a060020a0360043516610b1f565b34801561035757600080fd5b5061029a600160a060020a0360043581169060243516604435610b9d565b34801561038157600080fd5b5061029a600435600160a060020a036024358116906044359060643516608435610c69565b3480156103b257600080fd5b5061025f600435602435610c96565b3480156103cd57600080fd5b5061029a610d61565b3480156103e257600080fd5b5061025f6004351515610d67565b3480156103fc57600080fd5b5061025f600435610dfd565b34801561041457600080fd5b50610420600435611033565b60408051948552600160a060020a039384166020860152848101929092529091166060830152519081900360800190f35b34801561045d57600080fd5b5061025f600435611069565b34801561047557600080fd5b506102ef6004356001608060020a0360243516611168565b34801561049957600080fd5b5061029a600160a060020a036004351661118a565b3480156104ba57600080fd5b506104c36111a5565b6040805167ffffffffffffffff9092168252519081900360200190f35b3480156104ec57600080fd5b5061029a6111a9565b34801561050157600080fd5b5061029a6004356111af565b34801561051957600080fd5b506104c36111c1565b34801561052e57600080fd5b5061029a600160a060020a03600435811690602435166111d6565b34801561055557600080fd5b5061029a600160a060020a03600435811690602435166111f3565b34801561057c57600080fd5b5061025f611210565b34801561059157600080fd5b506102ef600435611226565b3480156105a957600080fd5b506102ef600160a060020a0360043516611326565b3480156105ca57600080fd5b5061029a600160a060020a03600435811690602435166113a0565b3480156105f157600080fd5b5061029a600160a060020a0360043581169060243590604435166064356113cb565b34801561061f57600080fd5b5061025f60043561153f565b34801561063757600080fd5b50610643600435611566565b60408051968752600160a060020a039586166020880152868101949094529184166060860152909216608084015267ffffffffffffffff90911660a0830152519081900360c00190f35b34801561069957600080fd5b5061029a6115b8565b3480156106ae57600080fd5b506106b76115be565b60408051600160a060020a039092168252519081900360200190f35b3480156106df57600080fd5b5061029a6004356115cd565b3480156106f757600080fd5b5061029a600160a060020a03600435166115df565b34801561071857600080fd5b5061029a6004356115f1565b34801561073057600080fd5b5061029a600435611606565b34801561074857600080fd5b506102ef600435611618565b34801561076057600080fd5b5061025f600160a060020a036004351660243561162f565b34801561078457600080fd5b506106b7611703565b34801561079957600080fd5b5061025f611712565b3480156107ae57600080fd5b506107ba600435611759565b60408051938452602084019290925282820152519081900360600190f35b3480156107e457600080fd5b506106b760043561177a565b3480156107fc57600080fd5b5061025f600435611798565b34801561081457600080fd5b5061025f6004351515611809565b34801561082e57600080fd5b5061025f60043560243561189d565b34801561084957600080fd5b5061029a600435600160a060020a03602435811690604435906064351660843560a4351515611947565b34801561087f57600080fd5b5061029a600435600160a060020a036024358116906044359060643516611a0f565b3480156108ad57600080fd5b5061025f611a96565b3480156108c257600080fd5b5061029a600160a060020a0360043581169060243516604435611aad565b6004546b010000000000000000000000900460ff1681565b600160a060020a038083166000908152600660209081526040808320938516835292905220545b92915050565b6004546000908190819060ff1615610975576040805160e560020a62461bcd0281526020600482015260126024820152600080516020613301833981519152604482015290519081900360640190fd5b6000861115610a9d5761098885886108f8565b915081151561099657600080fd5b6000828152600360205260409020600281015490546109b59190611b66565b86670de0b6b3a76400000210156109cb57610a9d565b6000828152600360205260409020600201548610610a3f576000828152600360205260409020546109fd908490611b97565b600083815260036020526040902060020154909350610a1d908790611ba7565b600083815260036020526040902054909650610a3a908390611168565b610a98565b60008281526003602052604090208054600290910154633b9aca0091610a719189840291610a6c91611bb7565b611bd3565b811515610a7a57fe5b049050610a878382611b97565b9250610a938282611168565b600095505b610975565b83831015610aaa57600080fd5b5050949350505050565b610aca33600035600160e060020a031916611c03565b1515610ad557600080fd5b6004805469ff00000000000000000019166901000000000000000000179055565b6000610b16836001608060020a031686846001608060020a031687611a0f565b95945050505050565b610b3533600035600160e060020a031916611c03565b1515610b4057600080fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383811691909117918290556040519116907fce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed9490600090a250565b600080610baa85856108f8565b90505b600081815260036020526040902060020154831115610c2757600081815260036020526040902054610be0908390611b97565b600082815260036020526040902060020154909250610c00908490611ba7565b92506000831115610c2257610c14816115f1565b9050801515610c2257600080fd5b610bad565b60008181526003602052604090208054600290910154610b16918491633b9aca0091610c5a9188840291610a6c91611bb7565b811515610c6357fe5b04611b97565b6000610c73611712565b15610c7d57600080fd5b610c8c86868686866001611947565b9695505050505050565b60045460009060ff1615610ce2576040805160e560020a62461bcd0281526020600482015260126024820152600080516020613301833981519152604482015290519081900360640190fd5b610ceb83611798565b15610cf557600080fd5b610cfe8361153f565b1515610d0957600080fd5b610d1283611d0a565b50610d1d8383611db2565b604080513381526020810185905281517f6d5c16212bdea16850dce4d9fa2314c446bd30ce84700d9c36c7677c6d283940929181900390910190a150600192915050565b60025481565b6000610d7f33600035600160e060020a031916611c03565b1515610d8a57600080fd5b600480548315156b0100000000000000000000009081026bff0000000000000000000000199092169190911791829055604080519190920460ff161515815290517fea11e00ec1642be9b494019b756440e2c57dbe9e59242c4f9c64ce33fb4f41d99181900360200190a1506001919050565b600081610e098161153f565b1515610e85576040805160e560020a62461bcd02815260206004820152602d60248201527f4f66666572207761732064656c65746564206f722074616b656e2c206f72206e60448201527f6576657220657869737465642e00000000000000000000000000000000000000606482015290519081900360840190fd5b610e8d611712565b80610eb15750610e9c8161177a565b600160a060020a031633600160a060020a0316145b80610ebd5750600b5481145b1515610f85576040805160e560020a62461bcd02815260206004820152607460248201527f4f666665722063616e206e6f742062652063616e63656c6c656420626563617560448201527f73652075736572206973206e6f74206f776e65722c20616e64206d61726b657460648201527f206973206f70656e2c20616e64206f666665722073656c6c732072657175697260848201527f656420616d6f756e74206f6620746f6b656e732e00000000000000000000000060a482015290519081900360c40190fd5b60045460ff1615610fce576040805160e560020a62461bcd0281526020600482015260126024820152600080516020613301833981519152604482015290519081900360640190fd5b6004546b010000000000000000000000900460ff161561102357610ff183611798565b1561100f57610fff83611f5c565b151561100a57600080fd5b611023565b61101883611d0a565b151561102357600080fd5b61102c8361211c565b9392505050565b600090815260036020819052604090912080546001820154600283015492909301549093600160a060020a039384169390911690565b60045460009060ff16156110b5576040805160e560020a62461bcd0281526020600482015260126024820152600080516020613301833981519152604482015290519081900360640190fd5b6110be8261153f565b1580156110db575060008281526005602052604090206002015415155b80156110fb57506000828152600560205260409020600201546009194301115b151561110657600080fd5b60008281526005602090815260408083208381556001810184905560020192909255815133815290810184905281517fcb9d6176c6aac6478ebb9a2754cdce22a944de29ed1f2642f8613884eba4b40c929181900390910190a1506001919050565b61117b826001608060020a03831661189d565b151561118657600080fd5b5050565b600160a060020a031660009081526008602052604090205490565b4290565b600b5481565b60009081526009602052604090205490565b600454610100900467ffffffffffffffff1681565b600760209081526000928352604080842090915290825290205481565b600660209081526000928352604080842090915290825290205481565b6004546901000000000000000000900460ff1681565b6000816112328161153f565b151561123d57600080fd5b611245611712565b1561124f57600080fd5b6000838152600360208181526040808420600481015460018201548286015484516c01000000000000000000000000600160a060020a03938416818102835292841690810260148301528651918290036028018220998d90529787528454600290950154918152958601969096526001608060020a039283168585015291909416606084015267ffffffffffffffff60a060020a850416608084015290518796509216929185917f70a14c213064359ede031fd2a1645a11ce2ec825ffe6ab5cfb5b160c3ef4d0a2919081900360a00190a4505050565b61133c33600035600160e060020a031916611c03565b151561134757600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03838116919091178083556040519116917f1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada491a250565b600160a060020a03918216600090815260076020908152604080832093909416825291909152205490565b600454600090819060ff1615611419576040805160e560020a62461bcd0281526020600482015260126024820152600080516020613301833981519152604482015290519081900360640190fd5b60008511156115295761142c86856108f8565b905080151561143a57600080fd5b6000818152600360205260409020805460029091015461145a9190611b66565b85670de0b6b3a764000002101561147057611529565b60008181526003602052604090205485106114e1576000818152600360205260409020600201546114a2908390611b97565b6000828152600360205260409020549092506114bf908690611ba7565b6000828152600360205260409020549095506114dc908290611168565b611524565b600081815260036020526040902060028101549054611513918491633b9aca0091610c5a918a840291610a6c91611bb7565b915061151f8186611168565b600094505b611419565b8282111561153657600080fd5b50949350505050565b60009081526003602052604081206004015460a060020a900467ffffffffffffffff161190565b6003602081905260009182526040909120805460018201546002830154938301546004909301549193600160a060020a039182169390929082169181169060a060020a900467ffffffffffffffff1686565b600a5490565b600154600160a060020a031681565b60009081526005602052604090205490565b60086020526000908152604090205481565b60009081526005602052604090206001015490565b60096020526000908152604090205481565b61162181610dfd565b151561162c57600080fd5b50565b600061164733600035600160e060020a031916611c03565b151561165257600080fd5b60408051348082526020820183815236938301849052600435936024359384938693339360008035600160e060020a031916949092606082018484808284376040519201829003965090945050505050a4600160a060020a0385166000818152600860209081526040918290208790558151928352820186905280517fc28d56449b0bb31e64ee7487e061f57a2e72aea8019d810832f26dda099823d09281900390910190a1506001949350505050565b600054600160a060020a031681565b6004546000906901000000000000000000900460ff16806117545750600454610100900467ffffffffffffffff166117486111a5565b67ffffffffffffffff16115b905090565b60056020526000908152604090208054600182015460029092015490919083565b600090815260036020526040902060040154600160a060020a031690565b6000818152600560205260408120541515806117c4575060008281526005602052604090206001015415155b8061091f57505060008181526003602081815260408084206001810154600160a060020a03908116865260068452828620919094015490931684529190529020541490565b600061182133600035600160e060020a031916611c03565b151561182c57600080fd5b600480548315156a01000000000000000000009081026aff00000000000000000000199092169190911791829055604080519190920460ff161515815290517f7089e4f0bcc948f9f723a361590c32d9c2284da7ab1981b1249ad2edb9f953c19181900360200190a1506001919050565b60006132c9836118ac8161153f565b15156118b757600080fd5b6118bf611712565b156118c957600080fd5b60045460ff1615611912576040805160e560020a62461bcd0281526020600482015260126024820152600080516020613301833981519152604482015290519081900360640190fd5b6004546b010000000000000000000000900460ff1661193357612623611937565b612ac65b9150610b1685858463ffffffff16565b6000611951611712565b1561195b57600080fd5b60045460ff16156119a4576040805160e560020a62461bcd0281526020600482015260126024820152600080516020613301833981519152604482015290519081900360640190fd5b600160a060020a0386166000908152600860205260409020548710156119c957600080fd5b6004546b010000000000000000000000900460ff16156119f8576119f1878787878787612b9c565b9050610c8c565b611a0487878787612d03565b979650505050505050565b6004546000906132c99060ff1615611a5f576040805160e560020a62461bcd0281526020600482015260126024820152600080516020613301833981519152604482015290519081900360640190fd5b6004546b010000000000000000000000900460ff16611a8057612d03611a84565b61303a5b9050610c8c868686868563ffffffff16565b6004546a0100000000000000000000900460ff1681565b600080611aba84866108f8565b90505b600081815260036020526040902054831115611b3457600081815260036020526040902060020154611af0908390611b97565b600082815260036020526040902054909250611b0d908490611ba7565b92506000831115611b2f57611b21816115f1565b9050801515611b2f57600080fd5b611abd565b600081815260036020526040902060028101549054610b16918491633b9aca0091610c5a9188840291610a6c91611bb7565b600081611b86611b7e85670de0b6b3a76400006130c4565b600285610c63565b811515611b8f57fe5b049392505050565b8082018281101561091f57600080fd5b8082038281111561091f57600080fd5b600081611b86611b7e856b033b2e3c9fd0803ce80000006130c4565b60006b033b2e3c9fd0803ce8000000611b86611bef85856130c4565b60026b033b2e3c9fd0803ce8000000610c63565b6000600160a060020a038316301415611c1e5750600161091f565b600154600160a060020a0384811691161415611c3c5750600161091f565b600054600160a060020a03161515611c565750600061091f565b60008054604080517fb7009613000000000000000000000000000000000000000000000000000000008152600160a060020a038781166004830152306024830152600160e060020a0319871660448301529151919092169263b700961392606480820193602093909283900390910190829087803b158015611cd757600080fd5b505af1158015611ceb573d6000803e3d6000fd5b505050506040513d6020811015611d0157600080fd5b5051905061091f565b600a5460009080611d1a84611798565b15611d2457600080fd5b83600a541415611d4b5760008481526009602052604081208054600a555560019250611dab565b5b600082118015611d5c5750838214155b15611d77575060008181526009602052604090205490611d4c565b818414611d875760009250611dab565b60008481526009602052604080822080548484529183209190915585825255600192505b5050919050565b6000806000611dc08561153f565b1515611dcb57600080fd5b600085815260036020819052604090912090810154600190910154600160a060020a039182169450169150831580611e205750600084815260036020526040902060010154600160a060020a03838116911614155b80611e49575060008481526003602081905260409091200154600160a060020a03848116911614155b80611e5a5750611e5884611798565b155b611e6d57611e6885856130ec565b611e76565b611e76856131cb565b93508315611ea457506000838152600560205260408082206001018054908790558683529120849055611ed1565b50600160a060020a0381811660009081526006602090815260408083209386168352929052208054908590555b8015611ef55760008181526005602052604080822087905586825290206001018190555b600160a060020a03808316600090815260076020908152604080832093871683529281529082902080546001019055815187815291517f20fb9bad86c18f7e22e8065258790d9416a7d2df8ff05f80f82c46d38b925acd9281900390910190a15050505050565b600081815260036020818152604080842092830154600190930154600160a060020a03908116808652600784528286209190941680865292528320549091908310611fa657600080fd5b600084815260056020526040902060020154158015611fc95750611fc984611798565b1515611fd457600080fd5b600160a060020a03808216600090815260066020908152604080832093861683529290522054841461204757600084815260056020526040808220548252902060010154841461202357600080fd5b6000848152600560205260408082206001808201549154845291909220015561207d565b600084815260056020908152604080832060010154600160a060020a038086168552600684528285209087168552909252909120555b600084815260056020526040902060010154156120d45760008481526005602052604080822060010154825290205484146120b757600080fd5b600084815260056020526040808220805460019091015483529120555b600160a060020a039081166000908152600760209081526040808320949093168252928352818120805460001901905593845260059091529091204360029091015550600190565b60006121266132cb565b826121308161153f565b15156121ac576040805160e560020a62461bcd02815260206004820152602d60248201527f4f66666572207761732064656c65746564206f722074616b656e2c206f72206e60448201527f6576657220657869737465642e00000000000000000000000000000000000000606482015290519081900360840190fd5b6121b4611712565b806121d857506121c38161177a565b600160a060020a031633600160a060020a0316145b806121e45750600b5481145b15156122ac576040805160e560020a62461bcd02815260206004820152607460248201527f4f666665722063616e206e6f742062652063616e63656c6c656420626563617560448201527f73652075736572206973206e6f74206f776e65722c20616e64206d61726b657460648201527f206973206f70656e2c20616e64206f666665722073656c6c732072657175697260848201527f656420616d6f756e74206f6620746f6b656e732e00000000000000000000000060a482015290519081900360c40190fd5b60045460ff16156122bc57600080fd5b6001600460006101000a81548160ff0219169083151502179055506003600085815260200190815260200160002060c06040519081016040529081600082015481526020016001820160009054906101000a9004600160a060020a0316600160a060020a0316600160a060020a03168152602001600282015481526020016003820160009054906101000a9004600160a060020a0316600160a060020a0316600160a060020a031681526020016004820160009054906101000a9004600160a060020a0316600160a060020a0316600160a060020a031681526020016004820160149054906101000a900467ffffffffffffffff1667ffffffffffffffff1667ffffffffffffffff16815250509150600360008581526020019081526020016000206000808201600090556001820160006101000a815490600160a060020a03021916905560028201600090556003820160006101000a815490600160a060020a0302191690556004820160006101000a815490600160a060020a0302191690556004820160146101000a81549067ffffffffffffffff021916905550508160200151600160a060020a031663a9059cbb836080015184600001516040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083600160a060020a0316600160a060020a0316815260200182815260200192505050602060405180830381600087803b1580156124e257600080fd5b505af11580156124f6573d6000803e3d6000fd5b505050506040513d602081101561250c57600080fd5b5051151561251957600080fd5b6040805185815290517fa2c251311b1a7a475913900a2a73dc9789a21b04bc737e050bbc506dd4eb34889181900360200190a16080808301516020808501805160608088018051604080516c01000000000000000000000000600160a060020a039687168102825292861690920260148301528051918290036028018220955192518b51828d01519487168452908616978301979097526001608060020a0396871682820152959091169181019190915267ffffffffffffffff4216958101959095529151919092169287917f9577941d28fff863bfbee4694a6a4a56fb09e169619189d2eaa750b5b48199959181900360a00190a450506004805460ff19169055506001919050565b600061262d6132cb565b6000846126398161153f565b151561264457600080fd5b61264c611712565b1561265657600080fd5b60045460ff161561266657600080fd5b60048054600160ff1990911681178255600088815260036020818152604092839020835160c081018552815480825295820154600160a060020a03908116938201939093526002820154948101859052928101548216606084015290940154938416608082015260a060020a90930467ffffffffffffffff1660a0840152919450906126f39087906130c4565b8115156126fc57fe5b0491506001608060020a038216821461271457600080fd5b6001608060020a038516851461272957600080fd5b841580612734575081155b8061273f5750825185115b8061274d5750826040015182115b1561275b5760009350612ab3565b82516127679086611ba7565b60008781526003602052604090819020919091558301516127889083611ba7565b6000878152600360209081526040808320600201939093556060860151608087015184517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152600160a060020a0391821660248201526044810188905294519116936323b872dd9360648083019493928390030190829087803b15801561281557600080fd5b505af1158015612829573d6000803e3d6000fd5b505050506040513d602081101561283f57600080fd5b5051151561284c57600080fd5b602080840151604080517fa9059cbb000000000000000000000000000000000000000000000000000000008152336004820152602481018990529051600160a060020a039092169263a9059cbb926044808401938290030181600087803b1580156128b657600080fd5b505af11580156128ca573d6000803e3d6000fd5b505050506040513d60208110156128e057600080fd5b505115156128ed57600080fd5b6040805187815290517fa2c251311b1a7a475913900a2a73dc9789a21b04bc737e050bbc506dd4eb34889181900360200190a16080808401516020808601805160608089018051604080516c01000000000000000000000000600160a060020a039687168102825292861690920260148301528051918290036028018220955192518f835292851696820196909652908316818601526001608060020a03808d16928201929092529088169581019590955267ffffffffffffffff421660a086015291513394939092169290917f3383e3357c77fd2e3a4b30deea81179bc70a795d053d14d5b7f2f01d0fd4596f9181900360c00190a48260600151600160a060020a03168360200151600160a060020a03167f819e390338feffe95e2de57172d6faf337853dfd15c7a09a32d76f7fd24438758785604051808381526020018281526020019250505060405180910390a36000868152600360205260409020541515612aae576000868152600360208190526040822082815560018101805473ffffffffffffffffffffffffffffffffffffffff19908116909155600282019390935590810180549092169091556004018054600160e060020a03191690555b600193505b50506004805460ff191690555092915050565b6004546000906a0100000000000000000000900460ff161515612ae857600080fd5b600083815260036020526040902054821415612b2657612b0783611798565b15612b1b57612b1583611f5c565b50612b26565b612b2483611d0a565b505b612b308383612623565b1515612b3b57600080fd5b612b448361153f565b8015612b7e575060008381526003602081815260408084206001810154600160a060020a0316855260088352908420549387905291905254105b15612b9357600b839055612b9183610dfd565b505b50600192915050565b60008060008060005b600160a060020a038089166000908152600660209081526040808320938e168352929052908120541115612ca4575050600160a060020a038087166000908152600660209081526040808320938c168352928152828220548083526003909152919020600281015490549193509085612c1f576000612c27565b808b8a840101015b612c318c836130c4565b01612c3c838b6130c4565b1115612c4757612ca4565b612c5a84612c55838c613254565b61189d565b50889250612c7189612c6c838c613254565b611ba7565b985082612c7e8a8d6130c4565b811515612c8757fe5b049a508a1580612c95575088155b15612c9f57612ca4565b612ba5565b600089118015612cb4575060008b115b8015612cd85750600160a060020a038a166000908152600860205260409020548b10155b15612cf557612ce98b8b8b8b612d03565b9450612cf58588611db2565b505050509695505050505050565b6000612d0d6132cb565b612d15611712565b15612d1f57600080fd5b60045460ff1615612d2f57600080fd5b6004805460ff191660011790556001608060020a0386168614612d5157600080fd5b6001608060020a0384168414612d6657600080fd5b60008611612d7357600080fd5b600160a060020a0385161515612d8857600080fd5b60008411612d9557600080fd5b600160a060020a0383161515612daa57600080fd5b600160a060020a038581169084161415612dc357600080fd5b858152600160a060020a038086166020830152604082018590528316606082015233608082015267ffffffffffffffff421660a0820152612e0261326b565b60008181526003602081815260408084208651815582870151600182018054600160a060020a0392831673ffffffffffffffffffffffffffffffffffffffff1991821617909155838901516002840155606089015195830180549683169682169690961790955560808801516004928301805460a08b015167ffffffffffffffff1660a060020a027fffffffff0000000000000000ffffffffffffffffffffffffffffffffffffffff9385169190981617919091169590951790945581517f23b872dd0000000000000000000000000000000000000000000000000000000081523391810191909152306024820152604481018c90529051949650918916936323b872dd936064808501948390030190829087803b158015612f2357600080fd5b505af1158015612f37573d6000803e3d6000fd5b505050506040513d6020811015612f4d57600080fd5b50511515612f5a57600080fd5b6040805183815290517fa2c251311b1a7a475913900a2a73dc9789a21b04bc737e050bbc506dd4eb34889181900360200190a1604080516c01000000000000000000000000600160a060020a0388811682810284529087169182026014840152835192839003602801832090835260208301919091526001608060020a03808a16838501528716606083015267ffffffffffffffff42166080830152915133929185917f773ff502687307abfa024ac9f62f9752a0d210dac2ffd9a29e38e12e2ea82c829181900360a00190a4506004805460ff19169055949350505050565b600160a060020a03831660009081526008602052604081205485101561305f57600080fd5b61306b85858585612d03565b600a80546000838152600960209081526040918290209290925591839055815183815291519293507f8173832a493e0a3989e521458e55bfe9feac9f9b675a94e100b9d5a85f81486292918290030190a1949350505050565b60008115806130e15750508082028282828115156130de57fe5b04145b151561091f57600080fd5b6000808084116130fb57600080fd5b8215801590613110575061310e8361153f565b155b1561312e5760009283526005602052604090922060010154916130fb565b8215156131455761313e846131cb565b91506131c4565b61314f8484613279565b1561318f575b821580159061316957506131698484613279565b15613187575060008281526005602052604090206001015491613155565b8091506131c4565b82158015906131a557506131a38484613279565b155b156131c057600092835260056020526040909220549161318f565b8291505b5092915050565b6000808080808086116131dd57600080fd5b505050600083815260036020818152604080842092830154600190930154600160a060020a039081168086526006845282862091909416808652925283205490935090915b811580159061323657506132368683613279565b15610b16575060008181526005602052604090206001015490613222565b600081831115613264578161102c565b5090919050565b600280546001019081905590565b600081815260036020526040808220600201548483529082205461329d91906130c4565b600084815260036020526040808220600201548583529120546132c091906130c4565b10159392505050565bfe5b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a08101919091529056005265656e7472616e637920617474656d70740000000000000000000000000000a165627a7a7230582070d9b1bb53fdc3bcb3297c97da72225e59da3f32a97ae9359d07e6a96556eddd0029000000000000000000000000000000000000000000000000000000005e3ea2`

// DeployOasis deploys a new Ethereum contract, binding an instance of Oasis to it.
func DeployOasis(auth *bind.TransactOpts, backend bind.ContractBackend, close_time uint64) (common.Address, *types.Transaction, *Oasis, error) {
	parsed, err := abi.JSON(strings.NewReader(OasisABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(OasisBin), backend, close_time)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Oasis{OasisCaller: OasisCaller{contract: contract}, OasisTransactor: OasisTransactor{contract: contract}, OasisFilterer: OasisFilterer{contract: contract}}, nil
}

// Oasis is an auto generated Go binding around an Ethereum contract.
type Oasis struct {
	OasisCaller     // Read-only binding to the contract
	OasisTransactor // Write-only binding to the contract
	OasisFilterer   // Log filterer for contract events
}

// OasisCaller is an auto generated read-only Go binding around an Ethereum contract.
type OasisCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OasisTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OasisTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OasisFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OasisFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OasisSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OasisSession struct {
	Contract     *Oasis            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OasisCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OasisCallerSession struct {
	Contract *OasisCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// OasisTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OasisTransactorSession struct {
	Contract     *OasisTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OasisRaw is an auto generated low-level Go binding around an Ethereum contract.
type OasisRaw struct {
	Contract *Oasis // Generic contract binding to access the raw methods on
}

// OasisCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OasisCallerRaw struct {
	Contract *OasisCaller // Generic read-only contract binding to access the raw methods on
}

// OasisTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OasisTransactorRaw struct {
	Contract *OasisTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOasis creates a new instance of Oasis, bound to a specific deployed contract.
func NewOasis(address common.Address, backend bind.ContractBackend) (*Oasis, error) {
	contract, err := bindOasis(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Oasis{OasisCaller: OasisCaller{contract: contract}, OasisTransactor: OasisTransactor{contract: contract}, OasisFilterer: OasisFilterer{contract: contract}}, nil
}

// NewOasisCaller creates a new read-only instance of Oasis, bound to a specific deployed contract.
func NewOasisCaller(address common.Address, caller bind.ContractCaller) (*OasisCaller, error) {
	contract, err := bindOasis(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OasisCaller{contract: contract}, nil
}

// NewOasisTransactor creates a new write-only instance of Oasis, bound to a specific deployed contract.
func NewOasisTransactor(address common.Address, transactor bind.ContractTransactor) (*OasisTransactor, error) {
	contract, err := bindOasis(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OasisTransactor{contract: contract}, nil
}

// NewOasisFilterer creates a new log filterer instance of Oasis, bound to a specific deployed contract.
func NewOasisFilterer(address common.Address, filterer bind.ContractFilterer) (*OasisFilterer, error) {
	contract, err := bindOasis(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OasisFilterer{contract: contract}, nil
}

// bindOasis binds a generic wrapper to an already deployed contract.
func bindOasis(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OasisABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Oasis *OasisRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Oasis.Contract.OasisCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Oasis *OasisRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Oasis.Contract.OasisTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Oasis *OasisRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Oasis.Contract.OasisTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Oasis *OasisCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Oasis.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Oasis *OasisTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Oasis.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Oasis *OasisTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Oasis.Contract.contract.Transact(opts, method, params...)
}

// Best is a free data retrieval call binding the contract method 0x74c1d7d3.
//
// Solidity: function _best(address , address ) constant returns(uint256)
func (_Oasis *OasisCaller) Best(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "_best", arg0, arg1)
	return *ret0, err
}

// Best is a free data retrieval call binding the contract method 0x74c1d7d3.
//
// Solidity: function _best(address , address ) constant returns(uint256)
func (_Oasis *OasisSession) Best(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _Oasis.Contract.Best(&_Oasis.CallOpts, arg0, arg1)
}

// Best is a free data retrieval call binding the contract method 0x74c1d7d3.
//
// Solidity: function _best(address , address ) constant returns(uint256)
func (_Oasis *OasisCallerSession) Best(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _Oasis.Contract.Best(&_Oasis.CallOpts, arg0, arg1)
}

// Dust is a free data retrieval call binding the contract method 0x91be90c8.
//
// Solidity: function _dust(address ) constant returns(uint256)
func (_Oasis *OasisCaller) Dust(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "_dust", arg0)
	return *ret0, err
}

// Dust is a free data retrieval call binding the contract method 0x91be90c8.
//
// Solidity: function _dust(address ) constant returns(uint256)
func (_Oasis *OasisSession) Dust(arg0 common.Address) (*big.Int, error) {
	return _Oasis.Contract.Dust(&_Oasis.CallOpts, arg0)
}

// Dust is a free data retrieval call binding the contract method 0x91be90c8.
//
// Solidity: function _dust(address ) constant returns(uint256)
func (_Oasis *OasisCallerSession) Dust(arg0 common.Address) (*big.Int, error) {
	return _Oasis.Contract.Dust(&_Oasis.CallOpts, arg0)
}

// Near is a free data retrieval call binding the contract method 0xa78d4316.
//
// Solidity: function _near(uint256 ) constant returns(uint256)
func (_Oasis *OasisCaller) Near(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "_near", arg0)
	return *ret0, err
}

// Near is a free data retrieval call binding the contract method 0xa78d4316.
//
// Solidity: function _near(uint256 ) constant returns(uint256)
func (_Oasis *OasisSession) Near(arg0 *big.Int) (*big.Int, error) {
	return _Oasis.Contract.Near(&_Oasis.CallOpts, arg0)
}

// Near is a free data retrieval call binding the contract method 0xa78d4316.
//
// Solidity: function _near(uint256 ) constant returns(uint256)
func (_Oasis *OasisCallerSession) Near(arg0 *big.Int) (*big.Int, error) {
	return _Oasis.Contract.Near(&_Oasis.CallOpts, arg0)
}

// Rank is a free data retrieval call binding the contract method 0xc2d526aa.
//
// Solidity: function _rank(uint256 ) constant returns(uint256 next, uint256 prev, uint256 delb)
func (_Oasis *OasisCaller) Rank(opts *bind.CallOpts, arg0 *big.Int) (struct {
	Next *big.Int
	Prev *big.Int
	Delb *big.Int
}, error) {
	ret := new(struct {
		Next *big.Int
		Prev *big.Int
		Delb *big.Int
	})
	out := ret
	err := _Oasis.contract.Call(opts, out, "_rank", arg0)
	return *ret, err
}

// Rank is a free data retrieval call binding the contract method 0xc2d526aa.
//
// Solidity: function _rank(uint256 ) constant returns(uint256 next, uint256 prev, uint256 delb)
func (_Oasis *OasisSession) Rank(arg0 *big.Int) (struct {
	Next *big.Int
	Prev *big.Int
	Delb *big.Int
}, error) {
	return _Oasis.Contract.Rank(&_Oasis.CallOpts, arg0)
}

// Rank is a free data retrieval call binding the contract method 0xc2d526aa.
//
// Solidity: function _rank(uint256 ) constant returns(uint256 next, uint256 prev, uint256 delb)
func (_Oasis *OasisCallerSession) Rank(arg0 *big.Int) (struct {
	Next *big.Int
	Prev *big.Int
	Delb *big.Int
}, error) {
	return _Oasis.Contract.Rank(&_Oasis.CallOpts, arg0)
}

// Span is a free data retrieval call binding the contract method 0x677170e1.
//
// Solidity: function _span(address , address ) constant returns(uint256)
func (_Oasis *OasisCaller) Span(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "_span", arg0, arg1)
	return *ret0, err
}

// Span is a free data retrieval call binding the contract method 0x677170e1.
//
// Solidity: function _span(address , address ) constant returns(uint256)
func (_Oasis *OasisSession) Span(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _Oasis.Contract.Span(&_Oasis.CallOpts, arg0, arg1)
}

// Span is a free data retrieval call binding the contract method 0x677170e1.
//
// Solidity: function _span(address , address ) constant returns(uint256)
func (_Oasis *OasisCallerSession) Span(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _Oasis.Contract.Span(&_Oasis.CallOpts, arg0, arg1)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() constant returns(address)
func (_Oasis *OasisCaller) Authority(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "authority")
	return *ret0, err
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() constant returns(address)
func (_Oasis *OasisSession) Authority() (common.Address, error) {
	return _Oasis.Contract.Authority(&_Oasis.CallOpts)
}

// Authority is a free data retrieval call binding the contract method 0xbf7e214f.
//
// Solidity: function authority() constant returns(address)
func (_Oasis *OasisCallerSession) Authority() (common.Address, error) {
	return _Oasis.Contract.Authority(&_Oasis.CallOpts)
}

// BuyEnabled is a free data retrieval call binding the contract method 0xf582d293.
//
// Solidity: function buyEnabled() constant returns(bool)
func (_Oasis *OasisCaller) BuyEnabled(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "buyEnabled")
	return *ret0, err
}

// BuyEnabled is a free data retrieval call binding the contract method 0xf582d293.
//
// Solidity: function buyEnabled() constant returns(bool)
func (_Oasis *OasisSession) BuyEnabled() (bool, error) {
	return _Oasis.Contract.BuyEnabled(&_Oasis.CallOpts)
}

// BuyEnabled is a free data retrieval call binding the contract method 0xf582d293.
//
// Solidity: function buyEnabled() constant returns(bool)
func (_Oasis *OasisCallerSession) BuyEnabled() (bool, error) {
	return _Oasis.Contract.BuyEnabled(&_Oasis.CallOpts)
}

// CloseTime is a free data retrieval call binding the contract method 0x6377ebca.
//
// Solidity: function close_time() constant returns(uint64)
func (_Oasis *OasisCaller) CloseTime(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "close_time")
	return *ret0, err
}

// CloseTime is a free data retrieval call binding the contract method 0x6377ebca.
//
// Solidity: function close_time() constant returns(uint64)
func (_Oasis *OasisSession) CloseTime() (uint64, error) {
	return _Oasis.Contract.CloseTime(&_Oasis.CallOpts)
}

// CloseTime is a free data retrieval call binding the contract method 0x6377ebca.
//
// Solidity: function close_time() constant returns(uint64)
func (_Oasis *OasisCallerSession) CloseTime() (uint64, error) {
	return _Oasis.Contract.CloseTime(&_Oasis.CallOpts)
}

// DustId is a free data retrieval call binding the contract method 0x56ad8764.
//
// Solidity: function dustId() constant returns(uint256)
func (_Oasis *OasisCaller) DustId(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "dustId")
	return *ret0, err
}

// DustId is a free data retrieval call binding the contract method 0x56ad8764.
//
// Solidity: function dustId() constant returns(uint256)
func (_Oasis *OasisSession) DustId() (*big.Int, error) {
	return _Oasis.Contract.DustId(&_Oasis.CallOpts)
}

// DustId is a free data retrieval call binding the contract method 0x56ad8764.
//
// Solidity: function dustId() constant returns(uint256)
func (_Oasis *OasisCallerSession) DustId() (*big.Int, error) {
	return _Oasis.Contract.DustId(&_Oasis.CallOpts)
}

// GetBestOffer is a free data retrieval call binding the contract method 0x0374fc6f.
//
// Solidity: function getBestOffer(address sell_gem, address buy_gem) constant returns(uint256)
func (_Oasis *OasisCaller) GetBestOffer(opts *bind.CallOpts, sell_gem common.Address, buy_gem common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getBestOffer", sell_gem, buy_gem)
	return *ret0, err
}

// GetBestOffer is a free data retrieval call binding the contract method 0x0374fc6f.
//
// Solidity: function getBestOffer(address sell_gem, address buy_gem) constant returns(uint256)
func (_Oasis *OasisSession) GetBestOffer(sell_gem common.Address, buy_gem common.Address) (*big.Int, error) {
	return _Oasis.Contract.GetBestOffer(&_Oasis.CallOpts, sell_gem, buy_gem)
}

// GetBestOffer is a free data retrieval call binding the contract method 0x0374fc6f.
//
// Solidity: function getBestOffer(address sell_gem, address buy_gem) constant returns(uint256)
func (_Oasis *OasisCallerSession) GetBestOffer(sell_gem common.Address, buy_gem common.Address) (*big.Int, error) {
	return _Oasis.Contract.GetBestOffer(&_Oasis.CallOpts, sell_gem, buy_gem)
}

// GetBetterOffer is a free data retrieval call binding the contract method 0x911550f4.
//
// Solidity: function getBetterOffer(uint256 id) constant returns(uint256)
func (_Oasis *OasisCaller) GetBetterOffer(opts *bind.CallOpts, id *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getBetterOffer", id)
	return *ret0, err
}

// GetBetterOffer is a free data retrieval call binding the contract method 0x911550f4.
//
// Solidity: function getBetterOffer(uint256 id) constant returns(uint256)
func (_Oasis *OasisSession) GetBetterOffer(id *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetBetterOffer(&_Oasis.CallOpts, id)
}

// GetBetterOffer is a free data retrieval call binding the contract method 0x911550f4.
//
// Solidity: function getBetterOffer(uint256 id) constant returns(uint256)
func (_Oasis *OasisCallerSession) GetBetterOffer(id *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetBetterOffer(&_Oasis.CallOpts, id)
}

// GetBuyAmount is a free data retrieval call binding the contract method 0x144a2752.
//
// Solidity: function getBuyAmount(address buy_gem, address pay_gem, uint256 pay_amt) constant returns(uint256 fill_amt)
func (_Oasis *OasisCaller) GetBuyAmount(opts *bind.CallOpts, buy_gem common.Address, pay_gem common.Address, pay_amt *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getBuyAmount", buy_gem, pay_gem, pay_amt)
	return *ret0, err
}

// GetBuyAmount is a free data retrieval call binding the contract method 0x144a2752.
//
// Solidity: function getBuyAmount(address buy_gem, address pay_gem, uint256 pay_amt) constant returns(uint256 fill_amt)
func (_Oasis *OasisSession) GetBuyAmount(buy_gem common.Address, pay_gem common.Address, pay_amt *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetBuyAmount(&_Oasis.CallOpts, buy_gem, pay_gem, pay_amt)
}

// GetBuyAmount is a free data retrieval call binding the contract method 0x144a2752.
//
// Solidity: function getBuyAmount(address buy_gem, address pay_gem, uint256 pay_amt) constant returns(uint256 fill_amt)
func (_Oasis *OasisCallerSession) GetBuyAmount(buy_gem common.Address, pay_gem common.Address, pay_amt *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetBuyAmount(&_Oasis.CallOpts, buy_gem, pay_gem, pay_amt)
}

// GetFirstUnsortedOffer is a free data retrieval call binding the contract method 0x8af82a2e.
//
// Solidity: function getFirstUnsortedOffer() constant returns(uint256)
func (_Oasis *OasisCaller) GetFirstUnsortedOffer(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getFirstUnsortedOffer")
	return *ret0, err
}

// GetFirstUnsortedOffer is a free data retrieval call binding the contract method 0x8af82a2e.
//
// Solidity: function getFirstUnsortedOffer() constant returns(uint256)
func (_Oasis *OasisSession) GetFirstUnsortedOffer() (*big.Int, error) {
	return _Oasis.Contract.GetFirstUnsortedOffer(&_Oasis.CallOpts)
}

// GetFirstUnsortedOffer is a free data retrieval call binding the contract method 0x8af82a2e.
//
// Solidity: function getFirstUnsortedOffer() constant returns(uint256)
func (_Oasis *OasisCallerSession) GetFirstUnsortedOffer() (*big.Int, error) {
	return _Oasis.Contract.GetFirstUnsortedOffer(&_Oasis.CallOpts)
}

// GetMinSell is a free data retrieval call binding the contract method 0x511fa487.
//
// Solidity: function getMinSell(address pay_gem) constant returns(uint256)
func (_Oasis *OasisCaller) GetMinSell(opts *bind.CallOpts, pay_gem common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getMinSell", pay_gem)
	return *ret0, err
}

// GetMinSell is a free data retrieval call binding the contract method 0x511fa487.
//
// Solidity: function getMinSell(address pay_gem) constant returns(uint256)
func (_Oasis *OasisSession) GetMinSell(pay_gem common.Address) (*big.Int, error) {
	return _Oasis.Contract.GetMinSell(&_Oasis.CallOpts, pay_gem)
}

// GetMinSell is a free data retrieval call binding the contract method 0x511fa487.
//
// Solidity: function getMinSell(address pay_gem) constant returns(uint256)
func (_Oasis *OasisCallerSession) GetMinSell(pay_gem common.Address) (*big.Int, error) {
	return _Oasis.Contract.GetMinSell(&_Oasis.CallOpts, pay_gem)
}

// GetNextUnsortedOffer is a free data retrieval call binding the contract method 0x61f54a79.
//
// Solidity: function getNextUnsortedOffer(uint256 id) constant returns(uint256)
func (_Oasis *OasisCaller) GetNextUnsortedOffer(opts *bind.CallOpts, id *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getNextUnsortedOffer", id)
	return *ret0, err
}

// GetNextUnsortedOffer is a free data retrieval call binding the contract method 0x61f54a79.
//
// Solidity: function getNextUnsortedOffer(uint256 id) constant returns(uint256)
func (_Oasis *OasisSession) GetNextUnsortedOffer(id *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetNextUnsortedOffer(&_Oasis.CallOpts, id)
}

// GetNextUnsortedOffer is a free data retrieval call binding the contract method 0x61f54a79.
//
// Solidity: function getNextUnsortedOffer(uint256 id) constant returns(uint256)
func (_Oasis *OasisCallerSession) GetNextUnsortedOffer(id *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetNextUnsortedOffer(&_Oasis.CallOpts, id)
}

// GetOffer is a free data retrieval call binding the contract method 0x4579268a.
//
// Solidity: function getOffer(uint256 id) constant returns(uint256, address, uint256, address)
func (_Oasis *OasisCaller) GetOffer(opts *bind.CallOpts, id *big.Int) (*big.Int, common.Address, *big.Int, common.Address, error) {
	var (
		ret0 = new(*big.Int)
		ret1 = new(common.Address)
		ret2 = new(*big.Int)
		ret3 = new(common.Address)
	)
	out := &[]interface{}{
		ret0,
		ret1,
		ret2,
		ret3,
	}
	err := _Oasis.contract.Call(opts, out, "getOffer", id)
	return *ret0, *ret1, *ret2, *ret3, err
}

// GetOffer is a free data retrieval call binding the contract method 0x4579268a.
//
// Solidity: function getOffer(uint256 id) constant returns(uint256, address, uint256, address)
func (_Oasis *OasisSession) GetOffer(id *big.Int) (*big.Int, common.Address, *big.Int, common.Address, error) {
	return _Oasis.Contract.GetOffer(&_Oasis.CallOpts, id)
}

// GetOffer is a free data retrieval call binding the contract method 0x4579268a.
//
// Solidity: function getOffer(uint256 id) constant returns(uint256, address, uint256, address)
func (_Oasis *OasisCallerSession) GetOffer(id *big.Int) (*big.Int, common.Address, *big.Int, common.Address, error) {
	return _Oasis.Contract.GetOffer(&_Oasis.CallOpts, id)
}

// GetOfferCount is a free data retrieval call binding the contract method 0x7ca9429a.
//
// Solidity: function getOfferCount(address sell_gem, address buy_gem) constant returns(uint256)
func (_Oasis *OasisCaller) GetOfferCount(opts *bind.CallOpts, sell_gem common.Address, buy_gem common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getOfferCount", sell_gem, buy_gem)
	return *ret0, err
}

// GetOfferCount is a free data retrieval call binding the contract method 0x7ca9429a.
//
// Solidity: function getOfferCount(address sell_gem, address buy_gem) constant returns(uint256)
func (_Oasis *OasisSession) GetOfferCount(sell_gem common.Address, buy_gem common.Address) (*big.Int, error) {
	return _Oasis.Contract.GetOfferCount(&_Oasis.CallOpts, sell_gem, buy_gem)
}

// GetOfferCount is a free data retrieval call binding the contract method 0x7ca9429a.
//
// Solidity: function getOfferCount(address sell_gem, address buy_gem) constant returns(uint256)
func (_Oasis *OasisCallerSession) GetOfferCount(sell_gem common.Address, buy_gem common.Address) (*big.Int, error) {
	return _Oasis.Contract.GetOfferCount(&_Oasis.CallOpts, sell_gem, buy_gem)
}

// GetOwner is a free data retrieval call binding the contract method 0xc41a360a.
//
// Solidity: function getOwner(uint256 id) constant returns(address owner)
func (_Oasis *OasisCaller) GetOwner(opts *bind.CallOpts, id *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getOwner", id)
	return *ret0, err
}

// GetOwner is a free data retrieval call binding the contract method 0xc41a360a.
//
// Solidity: function getOwner(uint256 id) constant returns(address owner)
func (_Oasis *OasisSession) GetOwner(id *big.Int) (common.Address, error) {
	return _Oasis.Contract.GetOwner(&_Oasis.CallOpts, id)
}

// GetOwner is a free data retrieval call binding the contract method 0xc41a360a.
//
// Solidity: function getOwner(uint256 id) constant returns(address owner)
func (_Oasis *OasisCallerSession) GetOwner(id *big.Int) (common.Address, error) {
	return _Oasis.Contract.GetOwner(&_Oasis.CallOpts, id)
}

// GetPayAmount is a free data retrieval call binding the contract method 0xff1fd974.
//
// Solidity: function getPayAmount(address pay_gem, address buy_gem, uint256 buy_amt) constant returns(uint256 fill_amt)
func (_Oasis *OasisCaller) GetPayAmount(opts *bind.CallOpts, pay_gem common.Address, buy_gem common.Address, buy_amt *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getPayAmount", pay_gem, buy_gem, buy_amt)
	return *ret0, err
}

// GetPayAmount is a free data retrieval call binding the contract method 0xff1fd974.
//
// Solidity: function getPayAmount(address pay_gem, address buy_gem, uint256 buy_amt) constant returns(uint256 fill_amt)
func (_Oasis *OasisSession) GetPayAmount(pay_gem common.Address, buy_gem common.Address, buy_amt *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetPayAmount(&_Oasis.CallOpts, pay_gem, buy_gem, buy_amt)
}

// GetPayAmount is a free data retrieval call binding the contract method 0xff1fd974.
//
// Solidity: function getPayAmount(address pay_gem, address buy_gem, uint256 buy_amt) constant returns(uint256 fill_amt)
func (_Oasis *OasisCallerSession) GetPayAmount(pay_gem common.Address, buy_gem common.Address, buy_amt *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetPayAmount(&_Oasis.CallOpts, pay_gem, buy_gem, buy_amt)
}

// GetTime is a free data retrieval call binding the contract method 0x557ed1ba.
//
// Solidity: function getTime() constant returns(uint64)
func (_Oasis *OasisCaller) GetTime(opts *bind.CallOpts) (uint64, error) {
	var (
		ret0 = new(uint64)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getTime")
	return *ret0, err
}

// GetTime is a free data retrieval call binding the contract method 0x557ed1ba.
//
// Solidity: function getTime() constant returns(uint64)
func (_Oasis *OasisSession) GetTime() (uint64, error) {
	return _Oasis.Contract.GetTime(&_Oasis.CallOpts)
}

// GetTime is a free data retrieval call binding the contract method 0x557ed1ba.
//
// Solidity: function getTime() constant returns(uint64)
func (_Oasis *OasisCallerSession) GetTime() (uint64, error) {
	return _Oasis.Contract.GetTime(&_Oasis.CallOpts)
}

// GetWorseOffer is a free data retrieval call binding the contract method 0x943911bc.
//
// Solidity: function getWorseOffer(uint256 id) constant returns(uint256)
func (_Oasis *OasisCaller) GetWorseOffer(opts *bind.CallOpts, id *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "getWorseOffer", id)
	return *ret0, err
}

// GetWorseOffer is a free data retrieval call binding the contract method 0x943911bc.
//
// Solidity: function getWorseOffer(uint256 id) constant returns(uint256)
func (_Oasis *OasisSession) GetWorseOffer(id *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetWorseOffer(&_Oasis.CallOpts, id)
}

// GetWorseOffer is a free data retrieval call binding the contract method 0x943911bc.
//
// Solidity: function getWorseOffer(uint256 id) constant returns(uint256)
func (_Oasis *OasisCallerSession) GetWorseOffer(id *big.Int) (*big.Int, error) {
	return _Oasis.Contract.GetWorseOffer(&_Oasis.CallOpts, id)
}

// IsActive is a free data retrieval call binding the contract method 0x82afd23b.
//
// Solidity: function isActive(uint256 id) constant returns(bool active)
func (_Oasis *OasisCaller) IsActive(opts *bind.CallOpts, id *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "isActive", id)
	return *ret0, err
}

// IsActive is a free data retrieval call binding the contract method 0x82afd23b.
//
// Solidity: function isActive(uint256 id) constant returns(bool active)
func (_Oasis *OasisSession) IsActive(id *big.Int) (bool, error) {
	return _Oasis.Contract.IsActive(&_Oasis.CallOpts, id)
}

// IsActive is a free data retrieval call binding the contract method 0x82afd23b.
//
// Solidity: function isActive(uint256 id) constant returns(bool active)
func (_Oasis *OasisCallerSession) IsActive(id *big.Int) (bool, error) {
	return _Oasis.Contract.IsActive(&_Oasis.CallOpts, id)
}

// IsClosed is a free data retrieval call binding the contract method 0xc2b6b58c.
//
// Solidity: function isClosed() constant returns(bool closed)
func (_Oasis *OasisCaller) IsClosed(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "isClosed")
	return *ret0, err
}

// IsClosed is a free data retrieval call binding the contract method 0xc2b6b58c.
//
// Solidity: function isClosed() constant returns(bool closed)
func (_Oasis *OasisSession) IsClosed() (bool, error) {
	return _Oasis.Contract.IsClosed(&_Oasis.CallOpts)
}

// IsClosed is a free data retrieval call binding the contract method 0xc2b6b58c.
//
// Solidity: function isClosed() constant returns(bool closed)
func (_Oasis *OasisCallerSession) IsClosed() (bool, error) {
	return _Oasis.Contract.IsClosed(&_Oasis.CallOpts)
}

// IsOfferSorted is a free data retrieval call binding the contract method 0xd2b420ce.
//
// Solidity: function isOfferSorted(uint256 id) constant returns(bool)
func (_Oasis *OasisCaller) IsOfferSorted(opts *bind.CallOpts, id *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "isOfferSorted", id)
	return *ret0, err
}

// IsOfferSorted is a free data retrieval call binding the contract method 0xd2b420ce.
//
// Solidity: function isOfferSorted(uint256 id) constant returns(bool)
func (_Oasis *OasisSession) IsOfferSorted(id *big.Int) (bool, error) {
	return _Oasis.Contract.IsOfferSorted(&_Oasis.CallOpts, id)
}

// IsOfferSorted is a free data retrieval call binding the contract method 0xd2b420ce.
//
// Solidity: function isOfferSorted(uint256 id) constant returns(bool)
func (_Oasis *OasisCallerSession) IsOfferSorted(id *big.Int) (bool, error) {
	return _Oasis.Contract.IsOfferSorted(&_Oasis.CallOpts, id)
}

// LastOfferId is a free data retrieval call binding the contract method 0x232cae0b.
//
// Solidity: function last_offer_id() constant returns(uint256)
func (_Oasis *OasisCaller) LastOfferId(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "last_offer_id")
	return *ret0, err
}

// LastOfferId is a free data retrieval call binding the contract method 0x232cae0b.
//
// Solidity: function last_offer_id() constant returns(uint256)
func (_Oasis *OasisSession) LastOfferId() (*big.Int, error) {
	return _Oasis.Contract.LastOfferId(&_Oasis.CallOpts)
}

// LastOfferId is a free data retrieval call binding the contract method 0x232cae0b.
//
// Solidity: function last_offer_id() constant returns(uint256)
func (_Oasis *OasisCallerSession) LastOfferId() (*big.Int, error) {
	return _Oasis.Contract.LastOfferId(&_Oasis.CallOpts)
}

// MatchingEnabled is a free data retrieval call binding the contract method 0x01492a0b.
//
// Solidity: function matchingEnabled() constant returns(bool)
func (_Oasis *OasisCaller) MatchingEnabled(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "matchingEnabled")
	return *ret0, err
}

// MatchingEnabled is a free data retrieval call binding the contract method 0x01492a0b.
//
// Solidity: function matchingEnabled() constant returns(bool)
func (_Oasis *OasisSession) MatchingEnabled() (bool, error) {
	return _Oasis.Contract.MatchingEnabled(&_Oasis.CallOpts)
}

// MatchingEnabled is a free data retrieval call binding the contract method 0x01492a0b.
//
// Solidity: function matchingEnabled() constant returns(bool)
func (_Oasis *OasisCallerSession) MatchingEnabled() (bool, error) {
	return _Oasis.Contract.MatchingEnabled(&_Oasis.CallOpts)
}

// Offers is a free data retrieval call binding the contract method 0x8a72ea6a.
//
// Solidity: function offers(uint256 ) constant returns(uint256 pay_amt, address pay_gem, uint256 buy_amt, address buy_gem, address owner, uint64 timestamp)
func (_Oasis *OasisCaller) Offers(opts *bind.CallOpts, arg0 *big.Int) (struct {
	PayAmt    *big.Int
	PayGem    common.Address
	BuyAmt    *big.Int
	BuyGem    common.Address
	Owner     common.Address
	Timestamp uint64
}, error) {
	ret := new(struct {
		PayAmt    *big.Int
		PayGem    common.Address
		BuyAmt    *big.Int
		BuyGem    common.Address
		Owner     common.Address
		Timestamp uint64
	})
	out := ret
	err := _Oasis.contract.Call(opts, out, "offers", arg0)
	return *ret, err
}

// Offers is a free data retrieval call binding the contract method 0x8a72ea6a.
//
// Solidity: function offers(uint256 ) constant returns(uint256 pay_amt, address pay_gem, uint256 buy_amt, address buy_gem, address owner, uint64 timestamp)
func (_Oasis *OasisSession) Offers(arg0 *big.Int) (struct {
	PayAmt    *big.Int
	PayGem    common.Address
	BuyAmt    *big.Int
	BuyGem    common.Address
	Owner     common.Address
	Timestamp uint64
}, error) {
	return _Oasis.Contract.Offers(&_Oasis.CallOpts, arg0)
}

// Offers is a free data retrieval call binding the contract method 0x8a72ea6a.
//
// Solidity: function offers(uint256 ) constant returns(uint256 pay_amt, address pay_gem, uint256 buy_amt, address buy_gem, address owner, uint64 timestamp)
func (_Oasis *OasisCallerSession) Offers(arg0 *big.Int) (struct {
	PayAmt    *big.Int
	PayGem    common.Address
	BuyAmt    *big.Int
	BuyGem    common.Address
	Owner     common.Address
	Timestamp uint64
}, error) {
	return _Oasis.Contract.Offers(&_Oasis.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Oasis *OasisCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Oasis *OasisSession) Owner() (common.Address, error) {
	return _Oasis.Contract.Owner(&_Oasis.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Oasis *OasisCallerSession) Owner() (common.Address, error) {
	return _Oasis.Contract.Owner(&_Oasis.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() constant returns(bool)
func (_Oasis *OasisCaller) Stopped(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Oasis.contract.Call(opts, out, "stopped")
	return *ret0, err
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() constant returns(bool)
func (_Oasis *OasisSession) Stopped() (bool, error) {
	return _Oasis.Contract.Stopped(&_Oasis.CallOpts)
}

// Stopped is a free data retrieval call binding the contract method 0x75f12b21.
//
// Solidity: function stopped() constant returns(bool)
func (_Oasis *OasisCallerSession) Stopped() (bool, error) {
	return _Oasis.Contract.Stopped(&_Oasis.CallOpts)
}

// Bump is a paid mutator transaction binding the contract method 0x779997c3.
//
// Solidity: function bump(bytes32 id_) returns()
func (_Oasis *OasisTransactor) Bump(opts *bind.TransactOpts, id_ [32]byte) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "bump", id_)
}

// Bump is a paid mutator transaction binding the contract method 0x779997c3.
//
// Solidity: function bump(bytes32 id_) returns()
func (_Oasis *OasisSession) Bump(id_ [32]byte) (*types.Transaction, error) {
	return _Oasis.Contract.Bump(&_Oasis.TransactOpts, id_)
}

// Bump is a paid mutator transaction binding the contract method 0x779997c3.
//
// Solidity: function bump(bytes32 id_) returns()
func (_Oasis *OasisTransactorSession) Bump(id_ [32]byte) (*types.Transaction, error) {
	return _Oasis.Contract.Bump(&_Oasis.TransactOpts, id_)
}

// Buy is a paid mutator transaction binding the contract method 0xd6febde8.
//
// Solidity: function buy(uint256 id, uint256 amount) returns(bool)
func (_Oasis *OasisTransactor) Buy(opts *bind.TransactOpts, id *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "buy", id, amount)
}

// Buy is a paid mutator transaction binding the contract method 0xd6febde8.
//
// Solidity: function buy(uint256 id, uint256 amount) returns(bool)
func (_Oasis *OasisSession) Buy(id *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Buy(&_Oasis.TransactOpts, id, amount)
}

// Buy is a paid mutator transaction binding the contract method 0xd6febde8.
//
// Solidity: function buy(uint256 id, uint256 amount) returns(bool)
func (_Oasis *OasisTransactorSession) Buy(id *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Buy(&_Oasis.TransactOpts, id, amount)
}

// BuyAllAmount is a paid mutator transaction binding the contract method 0x8185402b.
//
// Solidity: function buyAllAmount(address buy_gem, uint256 buy_amt, address pay_gem, uint256 max_fill_amount) returns(uint256 fill_amt)
func (_Oasis *OasisTransactor) BuyAllAmount(opts *bind.TransactOpts, buy_gem common.Address, buy_amt *big.Int, pay_gem common.Address, max_fill_amount *big.Int) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "buyAllAmount", buy_gem, buy_amt, pay_gem, max_fill_amount)
}

// BuyAllAmount is a paid mutator transaction binding the contract method 0x8185402b.
//
// Solidity: function buyAllAmount(address buy_gem, uint256 buy_amt, address pay_gem, uint256 max_fill_amount) returns(uint256 fill_amt)
func (_Oasis *OasisSession) BuyAllAmount(buy_gem common.Address, buy_amt *big.Int, pay_gem common.Address, max_fill_amount *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.BuyAllAmount(&_Oasis.TransactOpts, buy_gem, buy_amt, pay_gem, max_fill_amount)
}

// BuyAllAmount is a paid mutator transaction binding the contract method 0x8185402b.
//
// Solidity: function buyAllAmount(address buy_gem, uint256 buy_amt, address pay_gem, uint256 max_fill_amount) returns(uint256 fill_amt)
func (_Oasis *OasisTransactorSession) BuyAllAmount(buy_gem common.Address, buy_amt *big.Int, pay_gem common.Address, max_fill_amount *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.BuyAllAmount(&_Oasis.TransactOpts, buy_gem, buy_amt, pay_gem, max_fill_amount)
}

// Cancel is a paid mutator transaction binding the contract method 0x40e58ee5.
//
// Solidity: function cancel(uint256 id) returns(bool success)
func (_Oasis *OasisTransactor) Cancel(opts *bind.TransactOpts, id *big.Int) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "cancel", id)
}

// Cancel is a paid mutator transaction binding the contract method 0x40e58ee5.
//
// Solidity: function cancel(uint256 id) returns(bool success)
func (_Oasis *OasisSession) Cancel(id *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Cancel(&_Oasis.TransactOpts, id)
}

// Cancel is a paid mutator transaction binding the contract method 0x40e58ee5.
//
// Solidity: function cancel(uint256 id) returns(bool success)
func (_Oasis *OasisTransactorSession) Cancel(id *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Cancel(&_Oasis.TransactOpts, id)
}

// DelRank is a paid mutator transaction binding the contract method 0x467f0b7b.
//
// Solidity: function del_rank(uint256 id) returns(bool)
func (_Oasis *OasisTransactor) DelRank(opts *bind.TransactOpts, id *big.Int) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "del_rank", id)
}

// DelRank is a paid mutator transaction binding the contract method 0x467f0b7b.
//
// Solidity: function del_rank(uint256 id) returns(bool)
func (_Oasis *OasisSession) DelRank(id *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.DelRank(&_Oasis.TransactOpts, id)
}

// DelRank is a paid mutator transaction binding the contract method 0x467f0b7b.
//
// Solidity: function del_rank(uint256 id) returns(bool)
func (_Oasis *OasisTransactorSession) DelRank(id *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.DelRank(&_Oasis.TransactOpts, id)
}

// Insert is a paid mutator transaction binding the contract method 0x1d834a1b.
//
// Solidity: function insert(uint256 id, uint256 pos) returns(bool)
func (_Oasis *OasisTransactor) Insert(opts *bind.TransactOpts, id *big.Int, pos *big.Int) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "insert", id, pos)
}

// Insert is a paid mutator transaction binding the contract method 0x1d834a1b.
//
// Solidity: function insert(uint256 id, uint256 pos) returns(bool)
func (_Oasis *OasisSession) Insert(id *big.Int, pos *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Insert(&_Oasis.TransactOpts, id, pos)
}

// Insert is a paid mutator transaction binding the contract method 0x1d834a1b.
//
// Solidity: function insert(uint256 id, uint256 pos) returns(bool)
func (_Oasis *OasisTransactorSession) Insert(id *big.Int, pos *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Insert(&_Oasis.TransactOpts, id, pos)
}

// Kill is a paid mutator transaction binding the contract method 0xb4f9b6c8.
//
// Solidity: function kill(bytes32 id) returns()
func (_Oasis *OasisTransactor) Kill(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "kill", id)
}

// Kill is a paid mutator transaction binding the contract method 0xb4f9b6c8.
//
// Solidity: function kill(bytes32 id) returns()
func (_Oasis *OasisSession) Kill(id [32]byte) (*types.Transaction, error) {
	return _Oasis.Contract.Kill(&_Oasis.TransactOpts, id)
}

// Kill is a paid mutator transaction binding the contract method 0xb4f9b6c8.
//
// Solidity: function kill(bytes32 id) returns()
func (_Oasis *OasisTransactorSession) Kill(id [32]byte) (*types.Transaction, error) {
	return _Oasis.Contract.Kill(&_Oasis.TransactOpts, id)
}

// Make is a paid mutator transaction binding the contract method 0x093f5198.
//
// Solidity: function make(address pay_gem, address buy_gem, uint128 pay_amt, uint128 buy_amt) returns(bytes32)
func (_Oasis *OasisTransactor) Make(opts *bind.TransactOpts, pay_gem common.Address, buy_gem common.Address, pay_amt *big.Int, buy_amt *big.Int) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "make", pay_gem, buy_gem, pay_amt, buy_amt)
}

// Make is a paid mutator transaction binding the contract method 0x093f5198.
//
// Solidity: function make(address pay_gem, address buy_gem, uint128 pay_amt, uint128 buy_amt) returns(bytes32)
func (_Oasis *OasisSession) Make(pay_gem common.Address, buy_gem common.Address, pay_amt *big.Int, buy_amt *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Make(&_Oasis.TransactOpts, pay_gem, buy_gem, pay_amt, buy_amt)
}

// Make is a paid mutator transaction binding the contract method 0x093f5198.
//
// Solidity: function make(address pay_gem, address buy_gem, uint128 pay_amt, uint128 buy_amt) returns(bytes32)
func (_Oasis *OasisTransactorSession) Make(pay_gem common.Address, buy_gem common.Address, pay_amt *big.Int, buy_amt *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Make(&_Oasis.TransactOpts, pay_gem, buy_gem, pay_amt, buy_amt)
}

// Offer is a paid mutator transaction binding the contract method 0xf09ea2a6.
//
// Solidity: function offer(uint256 pay_amt, address pay_gem, uint256 buy_amt, address buy_gem) returns(uint256)
func (_Oasis *OasisTransactor) Offer(opts *bind.TransactOpts, pay_amt *big.Int, pay_gem common.Address, buy_amt *big.Int, buy_gem common.Address) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "offer", pay_amt, pay_gem, buy_amt, buy_gem)
}

// Offer is a paid mutator transaction binding the contract method 0xf09ea2a6.
//
// Solidity: function offer(uint256 pay_amt, address pay_gem, uint256 buy_amt, address buy_gem) returns(uint256)
func (_Oasis *OasisSession) Offer(pay_amt *big.Int, pay_gem common.Address, buy_amt *big.Int, buy_gem common.Address) (*types.Transaction, error) {
	return _Oasis.Contract.Offer(&_Oasis.TransactOpts, pay_amt, pay_gem, buy_amt, buy_gem)
}

// Offer is a paid mutator transaction binding the contract method 0xf09ea2a6.
//
// Solidity: function offer(uint256 pay_amt, address pay_gem, uint256 buy_amt, address buy_gem) returns(uint256)
func (_Oasis *OasisTransactorSession) Offer(pay_amt *big.Int, pay_gem common.Address, buy_amt *big.Int, buy_gem common.Address) (*types.Transaction, error) {
	return _Oasis.Contract.Offer(&_Oasis.TransactOpts, pay_amt, pay_gem, buy_amt, buy_gem)
}

// SellAllAmount is a paid mutator transaction binding the contract method 0x0621b4f6.
//
// Solidity: function sellAllAmount(address pay_gem, uint256 pay_amt, address buy_gem, uint256 min_fill_amount) returns(uint256 fill_amt)
func (_Oasis *OasisTransactor) SellAllAmount(opts *bind.TransactOpts, pay_gem common.Address, pay_amt *big.Int, buy_gem common.Address, min_fill_amount *big.Int) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "sellAllAmount", pay_gem, pay_amt, buy_gem, min_fill_amount)
}

// SellAllAmount is a paid mutator transaction binding the contract method 0x0621b4f6.
//
// Solidity: function sellAllAmount(address pay_gem, uint256 pay_amt, address buy_gem, uint256 min_fill_amount) returns(uint256 fill_amt)
func (_Oasis *OasisSession) SellAllAmount(pay_gem common.Address, pay_amt *big.Int, buy_gem common.Address, min_fill_amount *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.SellAllAmount(&_Oasis.TransactOpts, pay_gem, pay_amt, buy_gem, min_fill_amount)
}

// SellAllAmount is a paid mutator transaction binding the contract method 0x0621b4f6.
//
// Solidity: function sellAllAmount(address pay_gem, uint256 pay_amt, address buy_gem, uint256 min_fill_amount) returns(uint256 fill_amt)
func (_Oasis *OasisTransactorSession) SellAllAmount(pay_gem common.Address, pay_amt *big.Int, buy_gem common.Address, min_fill_amount *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.SellAllAmount(&_Oasis.TransactOpts, pay_gem, pay_amt, buy_gem, min_fill_amount)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Oasis *OasisTransactor) SetAuthority(opts *bind.TransactOpts, authority_ common.Address) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "setAuthority", authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Oasis *OasisSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Oasis.Contract.SetAuthority(&_Oasis.TransactOpts, authority_)
}

// SetAuthority is a paid mutator transaction binding the contract method 0x7a9e5e4b.
//
// Solidity: function setAuthority(address authority_) returns()
func (_Oasis *OasisTransactorSession) SetAuthority(authority_ common.Address) (*types.Transaction, error) {
	return _Oasis.Contract.SetAuthority(&_Oasis.TransactOpts, authority_)
}

// SetBuyEnabled is a paid mutator transaction binding the contract method 0xd6f15469.
//
// Solidity: function setBuyEnabled(bool buyEnabled_) returns(bool)
func (_Oasis *OasisTransactor) SetBuyEnabled(opts *bind.TransactOpts, buyEnabled_ bool) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "setBuyEnabled", buyEnabled_)
}

// SetBuyEnabled is a paid mutator transaction binding the contract method 0xd6f15469.
//
// Solidity: function setBuyEnabled(bool buyEnabled_) returns(bool)
func (_Oasis *OasisSession) SetBuyEnabled(buyEnabled_ bool) (*types.Transaction, error) {
	return _Oasis.Contract.SetBuyEnabled(&_Oasis.TransactOpts, buyEnabled_)
}

// SetBuyEnabled is a paid mutator transaction binding the contract method 0xd6f15469.
//
// Solidity: function setBuyEnabled(bool buyEnabled_) returns(bool)
func (_Oasis *OasisTransactorSession) SetBuyEnabled(buyEnabled_ bool) (*types.Transaction, error) {
	return _Oasis.Contract.SetBuyEnabled(&_Oasis.TransactOpts, buyEnabled_)
}

// SetMatchingEnabled is a paid mutator transaction binding the contract method 0x2aed1905.
//
// Solidity: function setMatchingEnabled(bool matchingEnabled_) returns(bool)
func (_Oasis *OasisTransactor) SetMatchingEnabled(opts *bind.TransactOpts, matchingEnabled_ bool) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "setMatchingEnabled", matchingEnabled_)
}

// SetMatchingEnabled is a paid mutator transaction binding the contract method 0x2aed1905.
//
// Solidity: function setMatchingEnabled(bool matchingEnabled_) returns(bool)
func (_Oasis *OasisSession) SetMatchingEnabled(matchingEnabled_ bool) (*types.Transaction, error) {
	return _Oasis.Contract.SetMatchingEnabled(&_Oasis.TransactOpts, matchingEnabled_)
}

// SetMatchingEnabled is a paid mutator transaction binding the contract method 0x2aed1905.
//
// Solidity: function setMatchingEnabled(bool matchingEnabled_) returns(bool)
func (_Oasis *OasisTransactorSession) SetMatchingEnabled(matchingEnabled_ bool) (*types.Transaction, error) {
	return _Oasis.Contract.SetMatchingEnabled(&_Oasis.TransactOpts, matchingEnabled_)
}

// SetMinSell is a paid mutator transaction binding the contract method 0xbf7c734e.
//
// Solidity: function setMinSell(address pay_gem, uint256 dust) returns(bool)
func (_Oasis *OasisTransactor) SetMinSell(opts *bind.TransactOpts, pay_gem common.Address, dust *big.Int) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "setMinSell", pay_gem, dust)
}

// SetMinSell is a paid mutator transaction binding the contract method 0xbf7c734e.
//
// Solidity: function setMinSell(address pay_gem, uint256 dust) returns(bool)
func (_Oasis *OasisSession) SetMinSell(pay_gem common.Address, dust *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.SetMinSell(&_Oasis.TransactOpts, pay_gem, dust)
}

// SetMinSell is a paid mutator transaction binding the contract method 0xbf7c734e.
//
// Solidity: function setMinSell(address pay_gem, uint256 dust) returns(bool)
func (_Oasis *OasisTransactorSession) SetMinSell(pay_gem common.Address, dust *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.SetMinSell(&_Oasis.TransactOpts, pay_gem, dust)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Oasis *OasisTransactor) SetOwner(opts *bind.TransactOpts, owner_ common.Address) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "setOwner", owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Oasis *OasisSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Oasis.Contract.SetOwner(&_Oasis.TransactOpts, owner_)
}

// SetOwner is a paid mutator transaction binding the contract method 0x13af4035.
//
// Solidity: function setOwner(address owner_) returns()
func (_Oasis *OasisTransactorSession) SetOwner(owner_ common.Address) (*types.Transaction, error) {
	return _Oasis.Contract.SetOwner(&_Oasis.TransactOpts, owner_)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Oasis *OasisTransactor) Stop(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "stop")
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Oasis *OasisSession) Stop() (*types.Transaction, error) {
	return _Oasis.Contract.Stop(&_Oasis.TransactOpts)
}

// Stop is a paid mutator transaction binding the contract method 0x07da68f5.
//
// Solidity: function stop() returns()
func (_Oasis *OasisTransactorSession) Stop() (*types.Transaction, error) {
	return _Oasis.Contract.Stop(&_Oasis.TransactOpts)
}

// Take is a paid mutator transaction binding the contract method 0x49606455.
//
// Solidity: function take(bytes32 id, uint128 maxTakeAmount) returns()
func (_Oasis *OasisTransactor) Take(opts *bind.TransactOpts, id [32]byte, maxTakeAmount *big.Int) (*types.Transaction, error) {
	return _Oasis.contract.Transact(opts, "take", id, maxTakeAmount)
}

// Take is a paid mutator transaction binding the contract method 0x49606455.
//
// Solidity: function take(bytes32 id, uint128 maxTakeAmount) returns()
func (_Oasis *OasisSession) Take(id [32]byte, maxTakeAmount *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Take(&_Oasis.TransactOpts, id, maxTakeAmount)
}

// Take is a paid mutator transaction binding the contract method 0x49606455.
//
// Solidity: function take(bytes32 id, uint128 maxTakeAmount) returns()
func (_Oasis *OasisTransactorSession) Take(id [32]byte, maxTakeAmount *big.Int) (*types.Transaction, error) {
	return _Oasis.Contract.Take(&_Oasis.TransactOpts, id, maxTakeAmount)
}

// OasisLogBumpIterator is returned from FilterLogBump and is used to iterate over the raw logs and unpacked data for LogBump events raised by the Oasis contract.
type OasisLogBumpIterator struct {
	Event *OasisLogBump // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogBumpIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogBump)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogBump)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogBumpIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogBumpIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogBump represents a LogBump event raised by the Oasis contract.
type OasisLogBump struct {
	Id        [32]byte
	Pair      [32]byte
	Maker     common.Address
	PayGem    common.Address
	BuyGem    common.Address
	PayAmt    *big.Int
	BuyAmt    *big.Int
	Timestamp uint64
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogBump is a free log retrieval operation binding the contract event 0x70a14c213064359ede031fd2a1645a11ce2ec825ffe6ab5cfb5b160c3ef4d0a2.
//
// Solidity: event LogBump(bytes32 indexed id, bytes32 indexed pair, address indexed maker, address pay_gem, address buy_gem, uint128 pay_amt, uint128 buy_amt, uint64 timestamp)
func (_Oasis *OasisFilterer) FilterLogBump(opts *bind.FilterOpts, id [][32]byte, pair [][32]byte, maker []common.Address) (*OasisLogBumpIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var pairRule []interface{}
	for _, pairItem := range pair {
		pairRule = append(pairRule, pairItem)
	}
	var makerRule []interface{}
	for _, makerItem := range maker {
		makerRule = append(makerRule, makerItem)
	}

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogBump", idRule, pairRule, makerRule)
	if err != nil {
		return nil, err
	}
	return &OasisLogBumpIterator{contract: _Oasis.contract, event: "LogBump", logs: logs, sub: sub}, nil
}

// WatchLogBump is a free log subscription operation binding the contract event 0x70a14c213064359ede031fd2a1645a11ce2ec825ffe6ab5cfb5b160c3ef4d0a2.
//
// Solidity: event LogBump(bytes32 indexed id, bytes32 indexed pair, address indexed maker, address pay_gem, address buy_gem, uint128 pay_amt, uint128 buy_amt, uint64 timestamp)
func (_Oasis *OasisFilterer) WatchLogBump(opts *bind.WatchOpts, sink chan<- *OasisLogBump, id [][32]byte, pair [][32]byte, maker []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var pairRule []interface{}
	for _, pairItem := range pair {
		pairRule = append(pairRule, pairItem)
	}
	var makerRule []interface{}
	for _, makerItem := range maker {
		makerRule = append(makerRule, makerItem)
	}

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogBump", idRule, pairRule, makerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogBump)
				if err := _Oasis.contract.UnpackLog(event, "LogBump", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogBuyEnabledIterator is returned from FilterLogBuyEnabled and is used to iterate over the raw logs and unpacked data for LogBuyEnabled events raised by the Oasis contract.
type OasisLogBuyEnabledIterator struct {
	Event *OasisLogBuyEnabled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogBuyEnabledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogBuyEnabled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogBuyEnabled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogBuyEnabledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogBuyEnabledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogBuyEnabled represents a LogBuyEnabled event raised by the Oasis contract.
type OasisLogBuyEnabled struct {
	IsEnabled bool
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogBuyEnabled is a free log retrieval operation binding the contract event 0x7089e4f0bcc948f9f723a361590c32d9c2284da7ab1981b1249ad2edb9f953c1.
//
// Solidity: event LogBuyEnabled(bool isEnabled)
func (_Oasis *OasisFilterer) FilterLogBuyEnabled(opts *bind.FilterOpts) (*OasisLogBuyEnabledIterator, error) {

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogBuyEnabled")
	if err != nil {
		return nil, err
	}
	return &OasisLogBuyEnabledIterator{contract: _Oasis.contract, event: "LogBuyEnabled", logs: logs, sub: sub}, nil
}

// WatchLogBuyEnabled is a free log subscription operation binding the contract event 0x7089e4f0bcc948f9f723a361590c32d9c2284da7ab1981b1249ad2edb9f953c1.
//
// Solidity: event LogBuyEnabled(bool isEnabled)
func (_Oasis *OasisFilterer) WatchLogBuyEnabled(opts *bind.WatchOpts, sink chan<- *OasisLogBuyEnabled) (event.Subscription, error) {

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogBuyEnabled")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogBuyEnabled)
				if err := _Oasis.contract.UnpackLog(event, "LogBuyEnabled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogDeleteIterator is returned from FilterLogDelete and is used to iterate over the raw logs and unpacked data for LogDelete events raised by the Oasis contract.
type OasisLogDeleteIterator struct {
	Event *OasisLogDelete // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogDeleteIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogDelete)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogDelete)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogDeleteIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogDeleteIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogDelete represents a LogDelete event raised by the Oasis contract.
type OasisLogDelete struct {
	Keeper common.Address
	Id     *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterLogDelete is a free log retrieval operation binding the contract event 0xcb9d6176c6aac6478ebb9a2754cdce22a944de29ed1f2642f8613884eba4b40c.
//
// Solidity: event LogDelete(address keeper, uint256 id)
func (_Oasis *OasisFilterer) FilterLogDelete(opts *bind.FilterOpts) (*OasisLogDeleteIterator, error) {

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogDelete")
	if err != nil {
		return nil, err
	}
	return &OasisLogDeleteIterator{contract: _Oasis.contract, event: "LogDelete", logs: logs, sub: sub}, nil
}

// WatchLogDelete is a free log subscription operation binding the contract event 0xcb9d6176c6aac6478ebb9a2754cdce22a944de29ed1f2642f8613884eba4b40c.
//
// Solidity: event LogDelete(address keeper, uint256 id)
func (_Oasis *OasisFilterer) WatchLogDelete(opts *bind.WatchOpts, sink chan<- *OasisLogDelete) (event.Subscription, error) {

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogDelete")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogDelete)
				if err := _Oasis.contract.UnpackLog(event, "LogDelete", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogInsertIterator is returned from FilterLogInsert and is used to iterate over the raw logs and unpacked data for LogInsert events raised by the Oasis contract.
type OasisLogInsertIterator struct {
	Event *OasisLogInsert // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogInsertIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogInsert)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogInsert)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogInsertIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogInsertIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogInsert represents a LogInsert event raised by the Oasis contract.
type OasisLogInsert struct {
	Keeper common.Address
	Id     *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterLogInsert is a free log retrieval operation binding the contract event 0x6d5c16212bdea16850dce4d9fa2314c446bd30ce84700d9c36c7677c6d283940.
//
// Solidity: event LogInsert(address keeper, uint256 id)
func (_Oasis *OasisFilterer) FilterLogInsert(opts *bind.FilterOpts) (*OasisLogInsertIterator, error) {

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogInsert")
	if err != nil {
		return nil, err
	}
	return &OasisLogInsertIterator{contract: _Oasis.contract, event: "LogInsert", logs: logs, sub: sub}, nil
}

// WatchLogInsert is a free log subscription operation binding the contract event 0x6d5c16212bdea16850dce4d9fa2314c446bd30ce84700d9c36c7677c6d283940.
//
// Solidity: event LogInsert(address keeper, uint256 id)
func (_Oasis *OasisFilterer) WatchLogInsert(opts *bind.WatchOpts, sink chan<- *OasisLogInsert) (event.Subscription, error) {

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogInsert")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogInsert)
				if err := _Oasis.contract.UnpackLog(event, "LogInsert", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogItemUpdateIterator is returned from FilterLogItemUpdate and is used to iterate over the raw logs and unpacked data for LogItemUpdate events raised by the Oasis contract.
type OasisLogItemUpdateIterator struct {
	Event *OasisLogItemUpdate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogItemUpdateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogItemUpdate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogItemUpdate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogItemUpdateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogItemUpdateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogItemUpdate represents a LogItemUpdate event raised by the Oasis contract.
type OasisLogItemUpdate struct {
	Id  *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogItemUpdate is a free log retrieval operation binding the contract event 0xa2c251311b1a7a475913900a2a73dc9789a21b04bc737e050bbc506dd4eb3488.
//
// Solidity: event LogItemUpdate(uint256 id)
func (_Oasis *OasisFilterer) FilterLogItemUpdate(opts *bind.FilterOpts) (*OasisLogItemUpdateIterator, error) {

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogItemUpdate")
	if err != nil {
		return nil, err
	}
	return &OasisLogItemUpdateIterator{contract: _Oasis.contract, event: "LogItemUpdate", logs: logs, sub: sub}, nil
}

// WatchLogItemUpdate is a free log subscription operation binding the contract event 0xa2c251311b1a7a475913900a2a73dc9789a21b04bc737e050bbc506dd4eb3488.
//
// Solidity: event LogItemUpdate(uint256 id)
func (_Oasis *OasisFilterer) WatchLogItemUpdate(opts *bind.WatchOpts, sink chan<- *OasisLogItemUpdate) (event.Subscription, error) {

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogItemUpdate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogItemUpdate)
				if err := _Oasis.contract.UnpackLog(event, "LogItemUpdate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogKillIterator is returned from FilterLogKill and is used to iterate over the raw logs and unpacked data for LogKill events raised by the Oasis contract.
type OasisLogKillIterator struct {
	Event *OasisLogKill // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogKillIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogKill)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogKill)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogKillIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogKillIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogKill represents a LogKill event raised by the Oasis contract.
type OasisLogKill struct {
	Id        [32]byte
	Pair      [32]byte
	Maker     common.Address
	PayGem    common.Address
	BuyGem    common.Address
	PayAmt    *big.Int
	BuyAmt    *big.Int
	Timestamp uint64
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogKill is a free log retrieval operation binding the contract event 0x9577941d28fff863bfbee4694a6a4a56fb09e169619189d2eaa750b5b4819995.
//
// Solidity: event LogKill(bytes32 indexed id, bytes32 indexed pair, address indexed maker, address pay_gem, address buy_gem, uint128 pay_amt, uint128 buy_amt, uint64 timestamp)
func (_Oasis *OasisFilterer) FilterLogKill(opts *bind.FilterOpts, id [][32]byte, pair [][32]byte, maker []common.Address) (*OasisLogKillIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var pairRule []interface{}
	for _, pairItem := range pair {
		pairRule = append(pairRule, pairItem)
	}
	var makerRule []interface{}
	for _, makerItem := range maker {
		makerRule = append(makerRule, makerItem)
	}

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogKill", idRule, pairRule, makerRule)
	if err != nil {
		return nil, err
	}
	return &OasisLogKillIterator{contract: _Oasis.contract, event: "LogKill", logs: logs, sub: sub}, nil
}

// WatchLogKill is a free log subscription operation binding the contract event 0x9577941d28fff863bfbee4694a6a4a56fb09e169619189d2eaa750b5b4819995.
//
// Solidity: event LogKill(bytes32 indexed id, bytes32 indexed pair, address indexed maker, address pay_gem, address buy_gem, uint128 pay_amt, uint128 buy_amt, uint64 timestamp)
func (_Oasis *OasisFilterer) WatchLogKill(opts *bind.WatchOpts, sink chan<- *OasisLogKill, id [][32]byte, pair [][32]byte, maker []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var pairRule []interface{}
	for _, pairItem := range pair {
		pairRule = append(pairRule, pairItem)
	}
	var makerRule []interface{}
	for _, makerItem := range maker {
		makerRule = append(makerRule, makerItem)
	}

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogKill", idRule, pairRule, makerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogKill)
				if err := _Oasis.contract.UnpackLog(event, "LogKill", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogMakeIterator is returned from FilterLogMake and is used to iterate over the raw logs and unpacked data for LogMake events raised by the Oasis contract.
type OasisLogMakeIterator struct {
	Event *OasisLogMake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogMakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogMake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogMake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogMakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogMakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogMake represents a LogMake event raised by the Oasis contract.
type OasisLogMake struct {
	Id        [32]byte       `abi:"id"`
	Pair      [32]byte       `abi:"pair"`
	Maker     common.Address `abi:"maker"`
	PayGem    common.Address `abi:"pay_gem"`
	BuyGem    common.Address `abi:"buy_gem"`
	PayAmt    *big.Int       `abi:"pay_amt"`
	BuyAmt    *big.Int       `abi:"buy_amt"`
	Timestamp uint64         `abi:"timestamp"`
	Raw       types.Log      // Blockchain specific contextual infos
}

// FilterLogMake is a free log retrieval operation binding the contract event 0x773ff502687307abfa024ac9f62f9752a0d210dac2ffd9a29e38e12e2ea82c82.
//
// Solidity: event LogMake(bytes32 indexed id, bytes32 indexed pair, address indexed maker, address pay_gem, address buy_gem, uint128 pay_amt, uint128 buy_amt, uint64 timestamp)
func (_Oasis *OasisFilterer) FilterLogMake(opts *bind.FilterOpts, id [][32]byte, pair [][32]byte, maker []common.Address) (*OasisLogMakeIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var pairRule []interface{}
	for _, pairItem := range pair {
		pairRule = append(pairRule, pairItem)
	}
	var makerRule []interface{}
	for _, makerItem := range maker {
		makerRule = append(makerRule, makerItem)
	}

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogMake", idRule, pairRule, makerRule)
	if err != nil {
		return nil, err
	}
	return &OasisLogMakeIterator{contract: _Oasis.contract, event: "LogMake", logs: logs, sub: sub}, nil
}

// WatchLogMake is a free log subscription operation binding the contract event 0x773ff502687307abfa024ac9f62f9752a0d210dac2ffd9a29e38e12e2ea82c82.
//
// Solidity: event LogMake(bytes32 indexed id, bytes32 indexed pair, address indexed maker, address pay_gem, address buy_gem, uint128 pay_amt, uint128 buy_amt, uint64 timestamp)
func (_Oasis *OasisFilterer) WatchLogMake(opts *bind.WatchOpts, sink chan<- *OasisLogMake, id [][32]byte, pair [][32]byte, maker []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var pairRule []interface{}
	for _, pairItem := range pair {
		pairRule = append(pairRule, pairItem)
	}
	var makerRule []interface{}
	for _, makerItem := range maker {
		makerRule = append(makerRule, makerItem)
	}

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogMake", idRule, pairRule, makerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogMake)
				if err := _Oasis.contract.UnpackLog(event, "LogMake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogMatchingEnabledIterator is returned from FilterLogMatchingEnabled and is used to iterate over the raw logs and unpacked data for LogMatchingEnabled events raised by the Oasis contract.
type OasisLogMatchingEnabledIterator struct {
	Event *OasisLogMatchingEnabled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogMatchingEnabledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogMatchingEnabled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogMatchingEnabled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogMatchingEnabledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogMatchingEnabledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogMatchingEnabled represents a LogMatchingEnabled event raised by the Oasis contract.
type OasisLogMatchingEnabled struct {
	IsEnabled bool
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogMatchingEnabled is a free log retrieval operation binding the contract event 0xea11e00ec1642be9b494019b756440e2c57dbe9e59242c4f9c64ce33fb4f41d9.
//
// Solidity: event LogMatchingEnabled(bool isEnabled)
func (_Oasis *OasisFilterer) FilterLogMatchingEnabled(opts *bind.FilterOpts) (*OasisLogMatchingEnabledIterator, error) {

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogMatchingEnabled")
	if err != nil {
		return nil, err
	}
	return &OasisLogMatchingEnabledIterator{contract: _Oasis.contract, event: "LogMatchingEnabled", logs: logs, sub: sub}, nil
}

// WatchLogMatchingEnabled is a free log subscription operation binding the contract event 0xea11e00ec1642be9b494019b756440e2c57dbe9e59242c4f9c64ce33fb4f41d9.
//
// Solidity: event LogMatchingEnabled(bool isEnabled)
func (_Oasis *OasisFilterer) WatchLogMatchingEnabled(opts *bind.WatchOpts, sink chan<- *OasisLogMatchingEnabled) (event.Subscription, error) {

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogMatchingEnabled")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogMatchingEnabled)
				if err := _Oasis.contract.UnpackLog(event, "LogMatchingEnabled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogMinSellIterator is returned from FilterLogMinSell and is used to iterate over the raw logs and unpacked data for LogMinSell events raised by the Oasis contract.
type OasisLogMinSellIterator struct {
	Event *OasisLogMinSell // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogMinSellIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogMinSell)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogMinSell)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogMinSellIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogMinSellIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogMinSell represents a LogMinSell event raised by the Oasis contract.
type OasisLogMinSell struct {
	PayGem    common.Address
	MinAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogMinSell is a free log retrieval operation binding the contract event 0xc28d56449b0bb31e64ee7487e061f57a2e72aea8019d810832f26dda099823d0.
//
// Solidity: event LogMinSell(address pay_gem, uint256 min_amount)
func (_Oasis *OasisFilterer) FilterLogMinSell(opts *bind.FilterOpts) (*OasisLogMinSellIterator, error) {

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogMinSell")
	if err != nil {
		return nil, err
	}
	return &OasisLogMinSellIterator{contract: _Oasis.contract, event: "LogMinSell", logs: logs, sub: sub}, nil
}

// WatchLogMinSell is a free log subscription operation binding the contract event 0xc28d56449b0bb31e64ee7487e061f57a2e72aea8019d810832f26dda099823d0.
//
// Solidity: event LogMinSell(address pay_gem, uint256 min_amount)
func (_Oasis *OasisFilterer) WatchLogMinSell(opts *bind.WatchOpts, sink chan<- *OasisLogMinSell) (event.Subscription, error) {

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogMinSell")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogMinSell)
				if err := _Oasis.contract.UnpackLog(event, "LogMinSell", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogSetAuthorityIterator is returned from FilterLogSetAuthority and is used to iterate over the raw logs and unpacked data for LogSetAuthority events raised by the Oasis contract.
type OasisLogSetAuthorityIterator struct {
	Event *OasisLogSetAuthority // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogSetAuthorityIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogSetAuthority)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogSetAuthority)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogSetAuthorityIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogSetAuthorityIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogSetAuthority represents a LogSetAuthority event raised by the Oasis contract.
type OasisLogSetAuthority struct {
	Authority common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogSetAuthority is a free log retrieval operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Oasis *OasisFilterer) FilterLogSetAuthority(opts *bind.FilterOpts, authority []common.Address) (*OasisLogSetAuthorityIterator, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return &OasisLogSetAuthorityIterator{contract: _Oasis.contract, event: "LogSetAuthority", logs: logs, sub: sub}, nil
}

// WatchLogSetAuthority is a free log subscription operation binding the contract event 0x1abebea81bfa2637f28358c371278fb15ede7ea8dd28d2e03b112ff6d936ada4.
//
// Solidity: event LogSetAuthority(address indexed authority)
func (_Oasis *OasisFilterer) WatchLogSetAuthority(opts *bind.WatchOpts, sink chan<- *OasisLogSetAuthority, authority []common.Address) (event.Subscription, error) {

	var authorityRule []interface{}
	for _, authorityItem := range authority {
		authorityRule = append(authorityRule, authorityItem)
	}

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogSetAuthority", authorityRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogSetAuthority)
				if err := _Oasis.contract.UnpackLog(event, "LogSetAuthority", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogSetOwnerIterator is returned from FilterLogSetOwner and is used to iterate over the raw logs and unpacked data for LogSetOwner events raised by the Oasis contract.
type OasisLogSetOwnerIterator struct {
	Event *OasisLogSetOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogSetOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogSetOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogSetOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogSetOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogSetOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogSetOwner represents a LogSetOwner event raised by the Oasis contract.
type OasisLogSetOwner struct {
	Owner common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterLogSetOwner is a free log retrieval operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Oasis *OasisFilterer) FilterLogSetOwner(opts *bind.FilterOpts, owner []common.Address) (*OasisLogSetOwnerIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return &OasisLogSetOwnerIterator{contract: _Oasis.contract, event: "LogSetOwner", logs: logs, sub: sub}, nil
}

// WatchLogSetOwner is a free log subscription operation binding the contract event 0xce241d7ca1f669fee44b6fc00b8eba2df3bb514eed0f6f668f8f89096e81ed94.
//
// Solidity: event LogSetOwner(address indexed owner)
func (_Oasis *OasisFilterer) WatchLogSetOwner(opts *bind.WatchOpts, sink chan<- *OasisLogSetOwner, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogSetOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogSetOwner)
				if err := _Oasis.contract.UnpackLog(event, "LogSetOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogSortedOfferIterator is returned from FilterLogSortedOffer and is used to iterate over the raw logs and unpacked data for LogSortedOffer events raised by the Oasis contract.
type OasisLogSortedOfferIterator struct {
	Event *OasisLogSortedOffer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogSortedOfferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogSortedOffer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogSortedOffer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogSortedOfferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogSortedOfferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogSortedOffer represents a LogSortedOffer event raised by the Oasis contract.
type OasisLogSortedOffer struct {
	Id  *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogSortedOffer is a free log retrieval operation binding the contract event 0x20fb9bad86c18f7e22e8065258790d9416a7d2df8ff05f80f82c46d38b925acd.
//
// Solidity: event LogSortedOffer(uint256 id)
func (_Oasis *OasisFilterer) FilterLogSortedOffer(opts *bind.FilterOpts) (*OasisLogSortedOfferIterator, error) {

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogSortedOffer")
	if err != nil {
		return nil, err
	}
	return &OasisLogSortedOfferIterator{contract: _Oasis.contract, event: "LogSortedOffer", logs: logs, sub: sub}, nil
}

// WatchLogSortedOffer is a free log subscription operation binding the contract event 0x20fb9bad86c18f7e22e8065258790d9416a7d2df8ff05f80f82c46d38b925acd.
//
// Solidity: event LogSortedOffer(uint256 id)
func (_Oasis *OasisFilterer) WatchLogSortedOffer(opts *bind.WatchOpts, sink chan<- *OasisLogSortedOffer) (event.Subscription, error) {

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogSortedOffer")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogSortedOffer)
				if err := _Oasis.contract.UnpackLog(event, "LogSortedOffer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogTakeIterator is returned from FilterLogTake and is used to iterate over the raw logs and unpacked data for LogTake events raised by the Oasis contract.
type OasisLogTakeIterator struct {
	Event *OasisLogTake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogTakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogTake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogTake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogTakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogTakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogTake represents a LogTake event raised by the Oasis contract.
type OasisLogTake struct {
	Id        [32]byte
	Pair      [32]byte
	Maker     common.Address
	PayGem    common.Address
	BuyGem    common.Address
	Taker     common.Address
	TakeAmt   *big.Int
	GiveAmt   *big.Int
	Timestamp uint64
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterLogTake is a free log retrieval operation binding the contract event 0x3383e3357c77fd2e3a4b30deea81179bc70a795d053d14d5b7f2f01d0fd4596f.
//
// Solidity: event LogTake(bytes32 id, bytes32 indexed pair, address indexed maker, address pay_gem, address buy_gem, address indexed taker, uint128 take_amt, uint128 give_amt, uint64 timestamp)
func (_Oasis *OasisFilterer) FilterLogTake(opts *bind.FilterOpts, pair [][32]byte, maker []common.Address, taker []common.Address) (*OasisLogTakeIterator, error) {

	var pairRule []interface{}
	for _, pairItem := range pair {
		pairRule = append(pairRule, pairItem)
	}
	var makerRule []interface{}
	for _, makerItem := range maker {
		makerRule = append(makerRule, makerItem)
	}

	var takerRule []interface{}
	for _, takerItem := range taker {
		takerRule = append(takerRule, takerItem)
	}

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogTake", pairRule, makerRule, takerRule)
	if err != nil {
		return nil, err
	}
	return &OasisLogTakeIterator{contract: _Oasis.contract, event: "LogTake", logs: logs, sub: sub}, nil
}

// WatchLogTake is a free log subscription operation binding the contract event 0x3383e3357c77fd2e3a4b30deea81179bc70a795d053d14d5b7f2f01d0fd4596f.
//
// Solidity: event LogTake(bytes32 id, bytes32 indexed pair, address indexed maker, address pay_gem, address buy_gem, address indexed taker, uint128 take_amt, uint128 give_amt, uint64 timestamp)
func (_Oasis *OasisFilterer) WatchLogTake(opts *bind.WatchOpts, sink chan<- *OasisLogTake, pair [][32]byte, maker []common.Address, taker []common.Address) (event.Subscription, error) {

	var pairRule []interface{}
	for _, pairItem := range pair {
		pairRule = append(pairRule, pairItem)
	}
	var makerRule []interface{}
	for _, makerItem := range maker {
		makerRule = append(makerRule, makerItem)
	}

	var takerRule []interface{}
	for _, takerItem := range taker {
		takerRule = append(takerRule, takerItem)
	}

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogTake", pairRule, makerRule, takerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogTake)
				if err := _Oasis.contract.UnpackLog(event, "LogTake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogTradeIterator is returned from FilterLogTrade and is used to iterate over the raw logs and unpacked data for LogTrade events raised by the Oasis contract.
type OasisLogTradeIterator struct {
	Event *OasisLogTrade // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogTradeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogTrade)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogTrade)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogTradeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogTradeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogTrade represents a LogTrade event raised by the Oasis contract.
type OasisLogTrade struct {
	PayAmt *big.Int
	PayGem common.Address
	BuyAmt *big.Int
	BuyGem common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterLogTrade is a free log retrieval operation binding the contract event 0x819e390338feffe95e2de57172d6faf337853dfd15c7a09a32d76f7fd2443875.
//
// Solidity: event LogTrade(uint256 pay_amt, address indexed pay_gem, uint256 buy_amt, address indexed buy_gem)
func (_Oasis *OasisFilterer) FilterLogTrade(opts *bind.FilterOpts, pay_gem []common.Address, buy_gem []common.Address) (*OasisLogTradeIterator, error) {

	var pay_gemRule []interface{}
	for _, pay_gemItem := range pay_gem {
		pay_gemRule = append(pay_gemRule, pay_gemItem)
	}

	var buy_gemRule []interface{}
	for _, buy_gemItem := range buy_gem {
		buy_gemRule = append(buy_gemRule, buy_gemItem)
	}

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogTrade", pay_gemRule, buy_gemRule)
	if err != nil {
		return nil, err
	}
	return &OasisLogTradeIterator{contract: _Oasis.contract, event: "LogTrade", logs: logs, sub: sub}, nil
}

// WatchLogTrade is a free log subscription operation binding the contract event 0x819e390338feffe95e2de57172d6faf337853dfd15c7a09a32d76f7fd2443875.
//
// Solidity: event LogTrade(uint256 pay_amt, address indexed pay_gem, uint256 buy_amt, address indexed buy_gem)
func (_Oasis *OasisFilterer) WatchLogTrade(opts *bind.WatchOpts, sink chan<- *OasisLogTrade, pay_gem []common.Address, buy_gem []common.Address) (event.Subscription, error) {

	var pay_gemRule []interface{}
	for _, pay_gemItem := range pay_gem {
		pay_gemRule = append(pay_gemRule, pay_gemItem)
	}

	var buy_gemRule []interface{}
	for _, buy_gemItem := range buy_gem {
		buy_gemRule = append(buy_gemRule, buy_gemItem)
	}

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogTrade", pay_gemRule, buy_gemRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogTrade)
				if err := _Oasis.contract.UnpackLog(event, "LogTrade", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// OasisLogUnsortedOfferIterator is returned from FilterLogUnsortedOffer and is used to iterate over the raw logs and unpacked data for LogUnsortedOffer events raised by the Oasis contract.
type OasisLogUnsortedOfferIterator struct {
	Event *OasisLogUnsortedOffer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OasisLogUnsortedOfferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OasisLogUnsortedOffer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OasisLogUnsortedOffer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OasisLogUnsortedOfferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OasisLogUnsortedOfferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OasisLogUnsortedOffer represents a LogUnsortedOffer event raised by the Oasis contract.
type OasisLogUnsortedOffer struct {
	Id  *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogUnsortedOffer is a free log retrieval operation binding the contract event 0x8173832a493e0a3989e521458e55bfe9feac9f9b675a94e100b9d5a85f814862.
//
// Solidity: event LogUnsortedOffer(uint256 id)
func (_Oasis *OasisFilterer) FilterLogUnsortedOffer(opts *bind.FilterOpts) (*OasisLogUnsortedOfferIterator, error) {

	logs, sub, err := _Oasis.contract.FilterLogs(opts, "LogUnsortedOffer")
	if err != nil {
		return nil, err
	}
	return &OasisLogUnsortedOfferIterator{contract: _Oasis.contract, event: "LogUnsortedOffer", logs: logs, sub: sub}, nil
}

// WatchLogUnsortedOffer is a free log subscription operation binding the contract event 0x8173832a493e0a3989e521458e55bfe9feac9f9b675a94e100b9d5a85f814862.
//
// Solidity: event LogUnsortedOffer(uint256 id)
func (_Oasis *OasisFilterer) WatchLogUnsortedOffer(opts *bind.WatchOpts, sink chan<- *OasisLogUnsortedOffer) (event.Subscription, error) {

	logs, sub, err := _Oasis.contract.WatchLogs(opts, "LogUnsortedOffer")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OasisLogUnsortedOffer)
				if err := _Oasis.contract.UnpackLog(event, "LogUnsortedOffer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}
